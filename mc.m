(def const (fn x (fn "" x)))
(def id (fn x x))
(def false (const id))
(def true (id const))
(def nil? (fn list ((list (const (const (const false)))) true)))
(def then-run-with (fn p (fn f (p f))))
(def then-run (fn p1 (fn p2 ((then-run-with p1) (const p2)))))
(def ostream.write (fn ostream (fn char (ostream char))))
(def stdout ())
(def left (fn value (fn first (fn "" (first value)))))
(def car left)
(def or (fn x (fn y (if x true (y ())))))
(def left? (fn either ((either (const true)) (const false))))
(def nat.0? left?)
(def nat.dec (fn nat ((nat left) id)))
(def nat.= (fn x (fn y (if (nat.0? x) (nat.0? y) (if (nat.0? y) false ((nat.= (nat.dec x)) (nat.dec y)))))))
(def char.= nat.=)
(def linefeed (car (symbol "
")))
(def carriage-return (car (symbol "")))
(def newline? (fn char ((or ((char.= char) linefeed)) (fn "" ((char.= char) carriage-return)))))
(def compose (fn f (fn g (fn x (f (g x))))))
(def impure (fn x (impure x)))
(def run-with (fn p (fn f ((then-run-with p) ((compose impure) f)))))
(def pair (fn first (fn second (fn x ((x first) second)))))
(def cons pair)
(def istream.readln (fn istream ((then-run-with istream) (fn char (if (newline? char) (impure ()) ((run-with (istream.readln istream)) (fn line ((cons char) line))))))))
(def stdin ())
(def and (fn x (fn y (if x (y ()) false))))
(def right (fn value (fn "" (fn second (second value)))))
(def cdr right)
(def list.= (fn f (fn list1 (fn list2 (if (nil? list1) (nil? list2) (if (nil? list2) false ((and ((f (car list1)) (car list2))) (fn "" (((list.= f) (cdr list1)) (cdr list2))))))))))
(def symbol.= (list.= char.=))
(def filter (fn list (fn f (if (nil? list) () (if (f (car list)) ((cons (car list)) ((filter (cdr list)) f)) ((filter (cdr list)) f))))))
(def not (fn x (if x false true)))
(def space (car (symbol " ")))
(def tab (car (symbol "	")))
(def whitespace? (fn char ((or ((char.= char) space)) (fn "" ((or ((char.= char) tab)) (fn "" (newline? char)))))))
(def swap (fn f (fn x (fn y ((f y) x)))))
(def apply (fn f (fn x (f x))))
(def with (swap apply))
(def second (fn pair (pair false)))
(def first (fn pair (pair true)))
(def type-name first)
(def is? (fn type (fn data ((symbol.= type) (type-name data)))))
(def error ())
(def concat (fn list1 (fn list2 (if (nil? list1) list2 ((cons (car list1)) ((concat (cdr list1)) list2))))))
(def symbol->list id)
(def as (fn type (fn data (if ((is? type) data) data (error ((concat (symbol->list (symbol "Could not cast "))) ((concat (symbol->list (type-name data))) ((concat (symbol->list (symbol " to "))) (symbol->list type)))))))))
(def field (fn type (fn name (fn data ((second ((as type) data)) name)))))
(def parse-result.expr ((field (symbol parse-result)) (symbol expr)))
(def open-parentheses (car (symbol "(")))
(def close-parentheses (car (symbol ")")))
(def fold (fn list (fn acc (fn f (if (nil? list) acc (((fold (cdr list)) ((f acc) (car list))) f))))))
(def object (fn type ((pair type) (fn name ((concat (symbol->list (symbol "Could not find field "))) ((concat (symbol->list name)) ((concat (symbol->list (symbol " for "))) (symbol->list type))))))))
(def derive (fn data (fn name (fn value ((pair (first data)) (fn field (if ((symbol.= field) name) value ((second data) field))))))))
(def data (fn type (fn fields (((fold fields) (object type)) (fn data (fn field (((derive data) (first field)) (second field))))))))
(def new-data' (fn type (fn names (fn fields (if (nil? names) ((data type) fields) (fn value (((new-data' type) (cdr names)) ((cons ((pair (car names)) value)) fields))))))))
(def new-data (fn type (fn names (((new-data' type) names) ()))))
(def list1 (fn a ((cons a) ())))
(def list2 (fn a (fn b ((cons a) (list1 b)))))
(def parse-result ((new-data (symbol parse-result)) ((list2 (symbol rest)) (symbol expr))))
(def list3 (fn a (fn b (fn c ((cons a) ((list2 b) c))))))
(def list4 (fn a (fn b (fn c (fn d ((cons a) (((list3 b) c) d)))))))
(def list-expr ((new-data (symbol list-expr)) ((((list4 (symbol exprs)) (symbol path)) (symbol start)) (symbol end))))
(def reverse' (fn list (fn acc (if (nil? list) acc ((reverse' (cdr list)) ((cons (car list)) acc))))))
(def reverse (fn list ((reverse' list) ())))
(def parse-result.rest ((field (symbol parse-result)) (symbol rest)))
(def list-expr? (is? (symbol list-expr)))
(def list-expr.end ((field (symbol list-expr)) (symbol end)))
(def identifier-expr.end ((field (symbol identifier-expr)) (symbol end)))
(def expr.end (fn expr (if (list-expr? expr) (list-expr.end expr) (identifier-expr.end expr))))
(def parse-list-expr (fn input (fn path (fn start (fn end (fn acc (if ((char.= (car input)) close-parentheses) ((parse-result (cdr input)) ((((list-expr (reverse acc)) path) start) end)) ((with (((parse-expr input) path) end)) (fn result (((((parse-list-expr (parse-result.rest result)) path) start) (expr.end (parse-result.expr result))) ((cons (parse-result.expr result)) acc)))))))))))
(def position ((new-data (symbol position)) ((list2 (symbol line)) (symbol char))))
(def position.line ((field (symbol position)) (symbol line)))
(def nat.inc right)
(def nat.+ (fn x (fn y (if (nat.0? y) x ((nat.+ (nat.inc x)) (nat.dec y))))))
(def nat.0 (left id))
(def nat.1 (right nat.0))
(def position.char ((field (symbol position)) (symbol char)))
(def next-char (fn p ((position (position.line p)) ((nat.+ nat.1) (position.char p)))))
(def quote (car (symbol "\"")))
(def identifier-expr ((new-data (symbol identifier-expr)) ((((list4 (symbol name)) (symbol path)) (symbol start)) (symbol end))))
(def backslash (car (symbol "\\")))
(def cddr ((compose cdr) cdr))
(def letter-t (car (symbol t)))
(def letter-n (car (symbol n)))
(def letter-r (car (symbol r)))
(def escape (fn char (if ((char.= char) letter-t) tab (if ((char.= char) letter-n) linefeed (if ((char.= char) letter-r) carriage-return char)))))
(def cadr ((compose car) cdr))
(def next-line (fn p ((position ((nat.+ nat.1) (position.line p))) nat.1)))
(def parse-identifier-literal-expr (fn input (fn path (fn start (fn end (fn acc ((with (car input)) (fn head (if ((char.= head) quote) ((parse-result (cdr input)) ((((identifier-expr (reverse acc)) path) start) end)) (if ((char.= head) backslash) (((((parse-identifier-literal-expr (cddr input)) path) start) (next-char (next-char end))) ((cons (escape (cadr input))) acc)) (if (newline? head) (((((parse-identifier-literal-expr (cdr input)) path) start) (next-line end)) ((cons head) acc)) (((((parse-identifier-literal-expr (cdr input)) path) start) (next-char end)) ((cons head) acc)))))))))))))
(def semicolon (car (symbol ";")))
(def parse-comment (fn input (fn path (fn position (if ((or (nil? input)) (fn "" (newline? (car input)))) (((parse-expr input) path) position) (((parse-comment (cdr input)) path) position))))))
(def separator? (fn char ((or (whitespace? char)) (fn "" ((or ((char.= char) open-parentheses)) (fn "" ((or ((char.= char) close-parentheses)) (fn "" ((or ((char.= char) semicolon)) (fn "" ((char.= char) quote)))))))))))
(def parse-identifier-expr (fn input (fn path (fn start (fn end (fn acc (if (separator? (car input)) ((parse-result input) ((((identifier-expr (reverse acc)) path) start) end)) (((((parse-identifier-expr (cdr input)) path) start) (next-char end)) ((cons (car input)) acc)))))))))
(def parse-expr (fn input (fn path (fn position ((with (car input)) (fn head (if ((char.= head) open-parentheses) (((((parse-list-expr (cdr input)) path) (next-char position)) (next-char position)) ()) (if ((char.= head) quote) (((((parse-identifier-literal-expr (cdr input)) path) (next-char position)) (next-char position)) ()) (if ((char.= head) semicolon) (((parse-comment (cdr input)) path) (next-char position)) (if (newline? head) (((parse-expr (cdr input)) path) (next-line position)) (if (whitespace? head) (((parse-expr (cdr input)) path) (next-char position)) (((((parse-identifier-expr input) path) position) position) ()))))))))))))
(def append (fn list (fn elem (if (nil? list) (list1 elem) ((cons (car list)) ((append (cdr list)) elem))))))
(def mangle-fn-name ())
(def repl-parse (fn line (fn index (parse-result.expr (((parse-expr ((append line) linefeed)) ((mangle-fn-name (symbol repl)) index)) ((position index) nat.1))))))
(def identifier-expr? (is? (symbol identifier-expr)))
(def tree-map-node-nil? (is? (symbol tree-map-node-nil)))
(def null (left ()))
(def compare<? (is? (symbol compare<)))
(def compare>? (is? (symbol compare>)))
(def fold-compare (fn compare (fn < (fn > (fn = (if (compare<? compare) (< compare) (if (compare>? compare) (> compare) (= compare))))))))
(def tree-map-node.key ((field (symbol tree-map-node)) (symbol key)))
(def tree-map-node.left ((field (symbol tree-map-node)) (symbol left)))
(def tree-map-node.right ((field (symbol tree-map-node)) (symbol right)))
(def some right)
(def tree-map-node.value ((field (symbol tree-map-node)) (symbol value)))
(def tree-map-node.get (fn node (fn compare (fn key (if (tree-map-node-nil? node) null ((((fold-compare ((compare key) (tree-map-node.key node))) (fn < (((tree-map-node.get (tree-map-node.left node)) compare) key))) (fn > (((tree-map-node.get (tree-map-node.right node)) compare) key))) (fn = (some (tree-map-node.value node)))))))))
(def tree-map.node ((field (symbol tree-map)) (symbol node)))
(def tree-map.compare ((field (symbol tree-map)) (symbol compare)))
(def tree-map.get (fn map (fn key (((tree-map-node.get (tree-map.node map)) (tree-map.compare map)) key))))
(def env.locals ((field (symbol env)) (symbol locals)))
(def right? (fn either ((either (const false)) (const true))))
(def some? right?)
(def env.globals ((field (symbol env)) (symbol globals)))
(def env.get (fn env' (fn name ((with ((tree-map.get (env.locals env')) name)) (fn option (if (some? option) option ((tree-map.get (env.globals env')) name)))))))
(def unnull (fn either ((either id) id)))
(def generate-result ((new-data (symbol generate-result)) (((list3 (symbol operation)) (symbol declarations)) (symbol env))))
(def global-variable? (is? (symbol global-variable)))
(def global-variable-operation ((new-data (symbol global-variable-operation)) ((list2 (symbol name)) (symbol path))))
(def global-variable.name ((field (symbol global-variable)) (symbol name)))
(def global-variable.path ((field (symbol global-variable)) (symbol path)))
(def local-variable-operation ((new-data (symbol local-variable-operation)) ((list2 (symbol name)) (symbol index))))
(def local-variable.name ((field (symbol local-variable)) (symbol name)))
(def local-variable.index ((field (symbol local-variable)) (symbol index)))
(def generate-identifier-expr' (fn variable (if (global-variable? variable) ((global-variable-operation (global-variable.name variable)) (global-variable.path variable)) ((local-variable-operation (local-variable.name variable)) (local-variable.index variable)))))
(def env.exprs ((field (symbol env)) (symbol exprs)))
(def file.read ())
(def file.child ())
(def mpm-root mpm-root)
(def mpm-ref-root ((file.child mpm-root) (symbol ref)))
(def normalize id)
(def mpm-get-ref (fn name (file.read ((file.child mpm-ref-root) (normalize name)))))
(def mpm-src-root ((file.child mpm-root) (symbol src)))
(def mpm-get-src (fn ref (file.read ((file.child mpm-src-root) ((concat ref) (symbol .m))))))
(def parse (fn input (fn path (fn position (fn acc (if (nil? input) (reverse acc) (if ((char.= linefeed) (car input)) ((((parse (cdr input)) path) (next-line position)) acc) (if (whitespace? (car input)) ((((parse (cdr input)) path) (next-char position)) acc) ((with (((parse-expr input) path) position)) (fn result ((((parse (parse-result.rest result)) path) (expr.end (parse-result.expr result))) ((cons (parse-result.expr result)) acc))))))))))))
(def start-position ((position nat.1) nat.1))
(def list5 (fn a (fn b (fn c (fn d (fn e ((cons a) ((((list4 b) c) d) e))))))))
(def list6 (fn a (fn b (fn c (fn d (fn e (fn f ((cons a) (((((list5 b) c) d) e) f)))))))))
(def env ((new-data (symbol env)) ((((((list6 (symbol exprs)) (symbol locals)) (symbol globals)) (symbol heap)) (symbol def)) (symbol index))))
(def env.heap ((field (symbol env)) (symbol heap)))
(def env.def ((field (symbol env)) (symbol def)))
(def env.index ((field (symbol env)) (symbol index)))
(def tree-map ((new-data (symbol tree-map)) ((list2 (symbol node)) (symbol compare))))
(def tree-map-node-nil (object (symbol tree-map-node-nil)))
(def empty-tree-map (fn compare ((tree-map tree-map-node-nil) compare)))
(def compare= (object (symbol compare=)))
(def compare< (object (symbol compare<)))
(def compare> (object (symbol compare>)))
(def compare=? (is? (symbol compare=)))
(def compare-list (fn compare (fn list1 (fn list2 (if ((and (nil? list1)) (fn "" (nil? list2))) compare= (if (nil? list1) compare< (if (nil? list2) compare> ((fn compare-result (if (compare=? compare-result) (((compare-list compare) (cdr list1)) (cdr list2)) compare-result)) ((compare (car list1)) (car list2))))))))))
(def nat.< (fn x (fn y (if (nat.0? x) (not (nat.0? y)) (if (nat.0? y) false ((nat.< (nat.dec x)) (nat.dec y)))))))
(def nat.> (swap nat.<))
(def compare-nat (fn nat1 (fn nat2 (if ((nat.> nat1) nat2) compare> (if ((nat.< nat1) nat2) compare< compare=)))))
(def char->nat id)
(def compare-char (fn char1 (fn char2 ((compare-nat (char->nat char1)) (char->nat char2)))))
(def compare-symbol (compare-list compare-char))
(def generate-result.env ((field (symbol generate-result)) (symbol env)))
(def generate-result.operation ((field (symbol generate-result)) (symbol operation)))
(def generate-result.declarations ((field (symbol generate-result)) (symbol declarations)))
(def generate-identifier-expr (fn name (fn env' ((with ((env.get env') name)) (fn option (if (some? option) ((with (unnull option)) (fn variable (impure (((generate-result (generate-identifier-expr' variable)) ()) env')))) (if (nil? (env.exprs env')) ((then-run-with (mpm-get-ref name)) (fn ref ((then-run-with (mpm-get-src ref)) (fn src ((with ((((parse src) ref) start-position) ())) (fn exprs ((generate-identifier-expr name) ((((((env exprs) (env.locals env')) (env.globals env')) (env.heap env')) (env.def env')) (env.index env'))))))))) ((then-run-with ((generate-expr (car (env.exprs env'))) ((((((env (cdr (env.exprs env'))) (empty-tree-map compare-symbol)) (env.globals env')) (env.heap env')) ()) nat.0))) (fn next ((run-with ((generate-identifier-expr name) ((((((env (env.exprs (generate-result.env next))) (env.locals env')) (env.globals (generate-result.env next))) (env.heap env')) (env.def env')) (env.index env')))) (fn result (((generate-result (generate-result.operation result)) ((concat (generate-result.declarations next)) (generate-result.declarations result))) (generate-result.env result)))))))))))))
(def identifier-expr.name ((field (symbol identifier-expr)) (symbol name)))
(def list-expr.exprs ((field (symbol list-expr)) (symbol exprs)))
(def nil-operation (object (symbol nil-operation)))
(def generate-nil (fn env' (impure (((generate-result nil-operation) ()) env'))))
(def if-operation ((new-data (symbol if-operation)) (((list3 (symbol cond)) (symbol true)) (symbol false))))
(def generate-if-expr (fn cond-expr (fn true-expr (fn false-expr (fn env' ((then-run-with ((generate-expr cond-expr) env')) (fn cond-result ((then-run-with ((generate-expr true-expr) (generate-result.env cond-result))) (fn true-result ((run-with ((generate-expr false-expr) (generate-result.env true-result))) (fn false-result (((generate-result (((if-operation (generate-result.operation cond-result)) (generate-result.operation true-result)) (generate-result.operation false-result))) ((concat (generate-result.declarations cond-result)) ((concat (generate-result.declarations true-result)) (generate-result.declarations false-result)))) (generate-result.env false-result)))))))))))))
(def caddr ((compose car) cddr))
(def cdddr ((compose cdr) cddr))
(def cadddr ((compose car) cdddr))
(def map (fn list (fn f (if (nil? list) () ((cons (f (car list))) ((map (cdr list)) f))))))
(def tree-map-node.fold (fn node (fn acc (fn f (if (tree-map-node-nil? node) acc (((tree-map-node.fold (tree-map-node.right node)) (((f (((tree-map-node.fold (tree-map-node.left node)) acc) f)) (tree-map-node.key node)) (tree-map-node.value node))) f))))))
(def tree-map.fold (fn map (fn acc (fn f (((tree-map-node.fold (tree-map.node map)) acc) f)))))
(def tree-map->list (fn map (((tree-map.fold map) ()) (fn list (fn key (fn value ((cons ((pair key) value)) list)))))))
(def null? left?)
(def local-variable? (is? (symbol local-variable)))
(def tree-map-node ((new-data (symbol tree-map-node)) ((((list4 (symbol left)) (symbol right)) (symbol key)) (symbol value))))
(def tree-map-node.put (fn node (fn compare (fn key (fn value (if (tree-map-node-nil? node) ((((tree-map-node tree-map-node-nil) tree-map-node-nil) key) value) ((((fold-compare ((compare key) (tree-map-node.key node))) (fn < ((((tree-map-node ((((tree-map-node.put (tree-map-node.left node)) compare) key) value)) (tree-map-node.right node)) (tree-map-node.key node)) (tree-map-node.value node)))) (fn > ((((tree-map-node (tree-map-node.left node)) ((((tree-map-node.put (tree-map-node.right node)) compare) key) value)) (tree-map-node.key node)) (tree-map-node.value node)))) (fn = ((((tree-map-node (tree-map-node.left node)) (tree-map-node.right node)) key) value)))))))))
(def tree-map.put (fn map (fn key (fn value ((tree-map ((((tree-map-node.put (tree-map.node map)) (tree-map.compare map)) key) value)) (tree-map.compare map))))))
(def tree-map.+ (fn map1 (fn map2 (((tree-map.fold map1) map2) (fn map (fn key (fn value (((tree-map.put map) key) value))))))))
(def closures (fn expr (fn env' (if (identifier-expr? expr) ((fn variable (if (null? variable) (empty-tree-map compare-symbol) (if (local-variable? (unnull variable)) (((tree-map.put (empty-tree-map compare-symbol)) (identifier-expr.name expr)) true) (empty-tree-map compare-symbol)))) ((env.get env') (identifier-expr.name expr))) (((fold (list-expr.exprs expr)) (empty-tree-map compare-symbol)) (fn map (fn expr ((tree-map.+ map) ((closures expr) env')))))))))
(def local-variable ((new-data (symbol local-variable)) ((list2 (symbol name)) (symbol index))))
(def fn-declaration ((new-data (symbol fn-declaration)) ((((list4 (symbol name)) (symbol path)) (symbol closures)) (symbol value))))
(def list-expr.path ((field (symbol list-expr)) (symbol path)))
(def identifier-expr.path ((field (symbol identifier-expr)) (symbol path)))
(def expr.path (fn expr (if (list-expr? expr) (list-expr.path expr) (identifier-expr.path expr))))
(def fn-operation ((new-data (symbol fn-operation)) (((((list5 (symbol path)) (symbol name)) (symbol arg)) (symbol value)) (symbol closures))))
(def fn-declaration.name ((field (symbol fn-declaration)) (symbol name)))
(def get (fn list (fn n (if (nat.0? n) (car list) ((get (cdr list)) (nat.dec n))))))
(def local-variable-operation.index ((field (symbol local-variable-operation)) (symbol index)))
(def interpret-local-variable-operation (fn operation (fn stack (fn heap ((get stack) (local-variable-operation.index operation))))))
(def global-variable-operation.name ((field (symbol global-variable-operation)) (symbol name)))
(def interpret-global-variable-operation (fn operation (fn stack (fn heap ((with (heap (global-variable-operation.name operation))) (fn value (if (null? value) (error ((concat (symbol->list (symbol "Could not find value "))) (global-variable-operation.name operation))) ((unnull value) heap))))))))
(def if-operation.cond ((field (symbol if-operation)) (symbol cond)))
(def if-operation.true ((field (symbol if-operation)) (symbol true)))
(def if-operation.false ((field (symbol if-operation)) (symbol false)))
(def interpret-if-operation (fn operation (fn stack (fn heap (if (((interpret-operation' (if-operation.cond operation)) stack) heap) (((interpret-operation' (if-operation.true operation)) stack) heap) (((interpret-operation' (if-operation.false operation)) stack) heap))))))
(def def-operation.name ((field (symbol def-operation)) (symbol name)))
(def interpret-def-operation (fn operation (fn stack (fn heap ((with (heap (def-operation.name operation))) (fn value (if (null? value) (error ((concat (symbol->list (symbol "Could not find value "))) (def-operation.name operation))) ((unnull value) heap))))))))
(def fn-operation.name ((field (symbol fn-operation)) (symbol name)))
(def fn-operation.closures ((field (symbol fn-operation)) (symbol closures)))
(def interpret-fn-operation (fn operation (fn stack (fn heap (fn arg ((with (heap (fn-operation.name operation))) (fn function (if (null? function) (error ((concat (symbol "Could not find synthetic function ")) (fn-operation.name operation))) (((unnull function) ((concat ((map (fn-operation.closures operation)) (fn closure (((interpret-operation' closure) stack) heap)))) ((cons arg) stack))) heap)))))))))
(def impure-operation.operation ((field (symbol impure-operation)) (symbol operation)))
(def interpret-impure-operation (fn operation (fn stack (fn heap (impure (((interpret-operation' (impure-operation.operation operation)) stack) heap))))))
(def symbol-operation.name ((field (symbol symbol-operation)) (symbol name)))
(def interpret-symbol-operation (fn operation (fn stack (fn heap (symbol-operation.name operation)))))
(def apply-operation.fn ((field (symbol apply-operation)) (symbol fn)))
(def apply-operation.arg ((field (symbol apply-operation)) (symbol arg)))
(def interpret-apply-operation (fn operation (fn stack (fn heap ((((interpret-operation' (apply-operation.fn operation)) stack) heap) (((interpret-operation' (apply-operation.arg operation)) stack) heap))))))
(def line-number-operation.operation ((field (symbol line-number-operation)) (symbol operation)))
(def interpret-line-number-operation (fn operation (interpret-operation' (line-number-operation.operation operation))))
(def interpret-nil-operation (fn operation (fn stack (fn heap ()))))
(def interpret-operation' (fn operation (fn stack (fn heap (((((fn type (if ((symbol.= type) (symbol local-variable-operation)) interpret-local-variable-operation (if ((symbol.= type) (symbol global-variable-operation)) interpret-global-variable-operation (if ((symbol.= type) (symbol if-operation)) interpret-if-operation (if ((symbol.= type) (symbol def-operation)) interpret-def-operation (if ((symbol.= type) (symbol fn-operation)) interpret-fn-operation (if ((symbol.= type) (symbol impure-operation)) interpret-impure-operation (if ((symbol.= type) (symbol symbol-operation)) interpret-symbol-operation (if ((symbol.= type) (symbol apply-operation)) interpret-apply-operation (if ((symbol.= type) (symbol line-number-operation)) interpret-line-number-operation (if ((symbol.= type) (symbol nil-operation)) interpret-nil-operation (error (symbol ...))))))))))))) (type-name operation)) operation) stack) heap)))))
(def fn-declaration.value ((field (symbol fn-declaration)) (symbol value)))
(def interpret-fn-declaration (fn declaration (fn heap (fn name (if ((symbol.= name) (fn-declaration.name declaration)) (some (fn stack (fn heap' (((interpret-operation' (fn-declaration.value declaration)) stack) heap')))) (heap name))))))
(def generate-fn-expr (fn name (fn expr (fn env' ((with ((mangle-fn-name (env.def env')) (env.index env'))) (fn mangled-name ((with ((((((env (env.exprs env')) (env.locals env')) (env.globals env')) (env.heap env')) (env.def env')) ((nat.+ nat.1) (env.index env')))) (fn new-env ((with ((map (tree-map->list ((closures expr) new-env))) first)) (fn closures ((run-with ((generate-expr expr) ((((((env (env.exprs new-env)) (second (((fold ((append closures) name)) ((pair nat.0) (env.locals new-env))) (fn vars (fn closure ((pair ((nat.+ nat.1) (first vars))) (((tree-map.put (second vars)) closure) ((local-variable closure) (first vars))))))))) (env.globals new-env)) (env.heap new-env)) mangled-name) (env.index new-env)))) (fn result ((with ((((fn-declaration mangled-name) (expr.path expr)) closures) (generate-result.operation result))) (fn declaration (((generate-result (((((fn-operation (expr.path expr)) mangled-name) name) (generate-result.operation result)) ((map closures) (fn closure (generate-identifier-expr' (unnull ((env.get new-env) closure))))))) ((append (generate-result.declarations result)) declaration)) ((((((env (env.exprs (generate-result.env result))) (env.locals new-env)) (env.globals (generate-result.env result))) ((interpret-fn-declaration declaration) (env.heap (generate-result.env result)))) (env.def new-env)) (env.index new-env)))))))))))))))))
(def global-variable ((new-data (symbol global-variable)) (((list3 (symbol name)) (symbol path)) (symbol macro?))))
(def def-declaration ((new-data (symbol def-declaration)) (((list3 (symbol name)) (symbol path)) (symbol value))))
(def def-operation ((new-data (symbol def-operation)) (((list3 (symbol name)) (symbol path)) (symbol value))))
(def def-declaration.name ((field (symbol def-declaration)) (symbol name)))
(def interpret-operation (fn operation (fn heap (((interpret-operation' operation) ()) heap))))
(def def-declaration.value ((field (symbol def-declaration)) (symbol value)))
(def interpret-def-declaration (fn declaration (fn heap (fn name (if ((symbol.= name) (def-declaration.name declaration)) (some (fn heap' ((interpret-operation (def-declaration.value declaration)) heap'))) (heap name))))))
(def generate-global-expr (fn macro? (fn name (fn expr (fn env' (if (some? ((env.get env') name)) (error ((concat name) (symbol " has already been defined"))) ((with ((((((env (env.exprs env')) (env.locals env')) (((tree-map.put (env.globals env')) name) (((global-variable name) (expr.path expr)) macro?))) (env.heap env')) (env.def env')) (env.index env'))) (fn new-env ((run-with ((generate-expr expr) ((((((env (env.exprs new-env)) (env.locals new-env)) (env.globals new-env)) (env.heap new-env)) name) (env.index new-env)))) (fn result ((with (((def-declaration name) (expr.path expr)) (generate-result.operation result))) (fn declaration (((generate-result (((def-operation name) (expr.path expr)) (generate-result.operation result))) ((cons declaration) (generate-result.declarations result))) ((((((env (env.exprs (generate-result.env result))) (env.locals (generate-result.env result))) (env.globals (generate-result.env result))) ((interpret-def-declaration declaration) (env.heap (generate-result.env result)))) (env.def new-env)) (env.index (generate-result.env result))))))))))))))))
(def generate-def-expr (generate-global-expr false))
(def impure-operation ((new-data (symbol impure-operation)) (list1 (symbol operation))))
(def generate-impure-expr (fn expr (fn env' ((run-with ((generate-expr expr) env')) (fn result (((generate-result (impure-operation (generate-result.operation result))) (generate-result.declarations result)) (generate-result.env result)))))))
(def generate-macro-expr (generate-global-expr true))
(def symbol-operation ((new-data (symbol symbol-operation)) (list1 (symbol name))))
(def generate-symbol-expr (fn name (fn env' (impure (((generate-result (symbol-operation name)) ()) env')))))
(def global-variable.macro? ((field (symbol global-variable)) (symbol macro?)))
(def env.macro? (fn env' (fn name ((with ((tree-map.get (env.globals env')) name)) (fn option (if (null? option) false (global-variable.macro? (unnull option))))))))
(def expr->list (fn expr (if (identifier-expr? expr) (left (identifier-expr.name expr)) (right ((map (list-expr.exprs expr)) expr->list)))))
(def list->expr (fn either ((either (fn name ((((identifier-expr name) ()) start-position) start-position))) (fn list ((((list-expr ((map list) list->expr)) ()) start-position) start-position)))))
(def identifier-expr.start ((field (symbol identifier-expr)) (symbol start)))
(def apply-operation ((new-data (symbol apply-operation)) ((list2 (symbol fn)) (symbol arg))))
(def generate-apply-expr' (fn fn-result (fn arg-result (((generate-result ((apply-operation (generate-result.operation fn-result)) (generate-result.operation arg-result))) ((concat (generate-result.declarations fn-result)) (generate-result.declarations arg-result))) (generate-result.env arg-result)))))
(def generate-apply-expr (fn fn (fn args (fn env' ((then-run-with ((generate-expr fn) env')) (fn fn-result (if ((and (identifier-expr? fn)) (fn "" ((env.macro? (generate-result.env fn-result)) (identifier-expr.name fn)))) ((with ((interpret-operation (generate-result.operation fn-result)) (env.heap (generate-result.env fn-result)))) (fn function ((generate-expr ((((list-expr ((map (function ((map args) expr->list))) list->expr)) (identifier-expr.path fn)) (identifier-expr.start fn)) (identifier-expr.end fn))) (generate-result.env fn-result)))) (((fold args) (impure fn-result)) (fn proc (fn arg ((then-run-with proc) (fn fn-result ((run-with ((generate-expr arg) (generate-result.env fn-result))) (fn arg-result ((generate-apply-expr' fn-result) arg-result)))))))))))))))
(def generate-list-expr (fn expr (fn env' ((with (list-expr.exprs expr)) (fn exprs (if (nil? exprs) (generate-nil env') ((with (if (identifier-expr? (car exprs)) (identifier-expr.name (car exprs)) ())) (fn name (if (((list.= char.=) name) (symbol->list (symbol if))) ((((generate-if-expr (cadr exprs)) (caddr exprs)) (cadddr exprs)) env') (if (((list.= char.=) name) (symbol->list (symbol fn))) (((generate-fn-expr (identifier-expr.name (cadr exprs))) (caddr exprs)) env') (if (((list.= char.=) name) (symbol->list (symbol def))) (((generate-def-expr (identifier-expr.name (cadr exprs))) (caddr exprs)) env') (if (((list.= char.=) name) (symbol->list (symbol impure))) ((generate-impure-expr (cadr exprs)) env') (if (((list.= char.=) name) (symbol->list (symbol macro))) (((generate-macro-expr (identifier-expr.name (cadr exprs))) (caddr exprs)) env') (if (((list.= char.=) name) (symbol->list (symbol symbol))) ((generate-symbol-expr (identifier-expr.name (cadr exprs))) env') (((generate-apply-expr (car exprs)) (cdr exprs)) env')))))))))))))))
(def line-number-operation ((new-data (symbol line-number-operation)) ((list2 (symbol operation)) (symbol line))))
(def list-expr.start ((field (symbol list-expr)) (symbol start)))
(def expr.start (fn expr (if (list-expr? expr) (list-expr.start expr) (identifier-expr.start expr))))
(def generate-expr (fn expr (fn env' ((run-with (if (identifier-expr? expr) ((generate-identifier-expr (identifier-expr.name expr)) env') ((generate-list-expr expr) env'))) (fn expr-result (((generate-result ((line-number-operation (generate-result.operation expr-result)) (position.line (expr.start expr)))) (generate-result.declarations expr-result)) (generate-result.env expr-result)))))))
(def interpret-declaration (fn declaration (fn heap ((((fn type (if ((symbol.= type) (symbol def-declaration)) interpret-def-declaration (if ((symbol.= type) (symbol fn-declaration)) interpret-fn-declaration (error (symbol ...))))) (type-name declaration)) declaration) heap))))
(def interpret-declarations (fn declarations (fn heap (((fold declarations) heap) (fn heap' (fn declaration ((interpret-declaration declaration) heap')))))))
(def repl-interpret-declarations (fn result (fn heap ((interpret-declarations (generate-result.declarations result)) heap))))
(def repl-interpret-operation (fn result (fn heap ((interpret-operation (generate-result.operation result)) heap))))
(def debug ())
(def repl (fn env' (fn heap (fn index ((then-run-with ((then-run ((ostream.write stdout) (car (symbol >)))) (istream.readln stdin))) (fn line (if ((symbol.= ((filter line) ((compose not) whitespace?))) (symbol "")) (impure ()) ((with ((char.= (car line)) (car (symbol !)))) (fn !? ((with ((repl-parse (if !? (cdr line) line)) index)) (fn expr ((then-run-with ((generate-expr expr) env')) (fn result ((with ((repl-interpret-declarations result) heap)) (fn new-heap ((with ((repl-interpret-operation result) new-heap)) (fn value (((if !? then-run-with with) value) (fn v (((((const repl) (debug v)) (generate-result.env result)) new-heap) (nat.inc index)))))))))))))))))))))
(def empty-heap (const null))
(def default-env (fn exprs ((((((env exprs) (empty-tree-map compare-symbol)) (empty-tree-map compare-symbol)) empty-heap) ()) nat.0)))
(def empty-repl (fn "" (((repl (default-env ())) empty-heap) nat.1)))
(def file.local-file ())
(def file.directory? ())
(def file.child-files ())
(def file.name ())
(def slash (car (symbol /)))
(def file.name-without-extension ())
(def parse-file (fn file (fn path (fn init ((then-run-with (file.directory? file)) (fn directory? (if directory? ((then-run-with (file.child-files file)) (fn child-files (((fold child-files) (impure ())) (fn acc (fn child ((then-run-with (((parse-file child) (if init () ((concat path) ((append (file.name file)) slash)))) false)) (fn parse ((run-with acc) (fn exprs ((concat exprs) parse)))))))))) ((run-with (file.read file)) (fn chars ((((parse chars) ((concat path) (file.name-without-extension file))) ((position nat.1) nat.1)) ()))))))))))
(def generate-env (fn env' (if (nil? (env.exprs env')) (impure (((generate-result nil-operation) ()) env')) ((then-run-with ((generate-expr (car (env.exprs env'))) ((((((env (cdr (env.exprs env'))) (env.locals env')) (env.globals env')) (env.heap env')) (env.def env')) (env.index env')))) (fn car-result ((run-with (generate-env (generate-result.env car-result))) (fn cdr-result (((generate-result (generate-result.operation cdr-result)) ((concat (generate-result.declarations car-result)) (generate-result.declarations cdr-result))) (generate-result.env cdr-result)))))))))
(def generate (fn in ((then-run-with (((parse-file in) ()) true)) (fn exprs (generate-env (default-env exprs))))))
(def run-repl (fn in ((then-run-with (generate in)) (fn result (((repl (generate-result.env result)) ((interpret-declarations (generate-result.declarations result)) empty-heap)) nat.1)))))
(def write-program ())
(def write-result (fn result (fn out (((write-program out) (generate-result.operation result)) (generate-result.declarations result)))))
(def compile (fn in (fn out ((then-run-with (generate in)) (fn result ((write-result result) out))))))
(def "" (fn args (if (nil? args) (empty-repl ()) ((with ((file.child file.local-file) (car args))) (fn in (if (nil? (cdr args)) (run-repl in) ((with ((file.child file.local-file) (cadr args))) (fn out (if (nil? (cddr args)) ((compile in) out) (error (symbol "Too many arguments.")))))))))))
(def def-operation.value ((field (symbol def-operation)) (symbol value)))
(def fn-operation.value ((field (symbol fn-operation)) (symbol value)))
(def operation.fold (fn operation (fn acc (fn f ((f ((with (type-name operation)) (fn type (if ((symbol.= type) (symbol local-variable-operation)) acc (if ((symbol.= type) (symbol global-variable-operation)) acc (if ((symbol.= type) (symbol if-operation)) (((operation.fold (if-operation.false operation)) (((operation.fold (if-operation.true operation)) (((operation.fold (if-operation.cond operation)) acc) f)) f)) f) (if ((symbol.= type) (symbol def-operation)) (((operation.fold (def-operation.value operation)) acc) f) (if ((symbol.= type) (symbol fn-operation)) (((operation.fold (fn-operation.value operation)) acc) f) (if ((symbol.= type) (symbol impure-operation)) (((operation.fold (impure-operation.operation operation)) acc) f) (if ((symbol.= type) (symbol symbol-operation)) acc (if ((symbol.= type) (symbol apply-operation)) (((operation.fold (apply-operation.arg operation)) (((operation.fold (apply-operation.fn operation)) acc) f)) f) (if ((symbol.= type) (symbol line-number-operation)) (((operation.fold (line-number-operation.operation operation)) acc) f) (if ((symbol.= type) (symbol nil-operation)) acc (error (symbol ...))))))))))))))) operation)))))
(def def-declaration? (is? (symbol def-declaration)))
(def declaration.value (fn declaration (if (def-declaration? declaration) (def-declaration.value declaration) (fn-declaration.value declaration))))
(def declaration-dependencies (fn map (fn acc (fn name (fn declaration (if (some? ((tree-map.get (first acc)) name)) acc ((with (((operation.fold (declaration.value declaration)) ((pair (((tree-map.put (first acc)) name) true)) (second acc))) (fn acc (fn operation (if ((is? (symbol global-variable-operation)) operation) ((((declaration-dependencies map) acc) (global-variable-operation.name operation)) (unnull ((tree-map.get map) (global-variable-operation.name operation)))) acc))))) (fn new-acc ((pair (first new-acc)) ((cons declaration) (second new-acc)))))))))))
(def declaration.name (fn declaration (if (def-declaration? declaration) (def-declaration.name declaration) (fn-declaration.name declaration))))
(def declarations->declaration-map (fn declarations (((fold declarations) (empty-tree-map compare-symbol)) (fn map (fn declaration (((tree-map.put map) (declaration.name declaration)) declaration))))))
(def def-declaration.path ((field (symbol def-declaration)) (symbol path)))
(def def-operation.path ((field (symbol def-operation)) (symbol path)))
(def flat-map (fn list (fn f (if (nil? list) () ((concat (f (car list))) ((flat-map (cdr list)) f))))))
(def desugar-should-quote? (fn name (if (nil? name) false ((with (car name)) (fn char (if ((char.= char) quote) true (if ((char.= char) backslash) true (if ((char.= char) open-parentheses) true (if ((char.= char) close-parentheses) true (if ((char.= char) semicolon) true (if ((char.= char) (car (symbol "_"))) true (if (whitespace? char) true (desugar-should-quote? (cdr name))))))))))))))
(def desugar-quote (fn name (if ((or (desugar-should-quote? name)) (fn "" (nil? name))) ((with ((flat-map name) (fn char (if ((char.= char) quote) (symbol "\\\"") (if ((char.= char) backslash) (symbol "\\\\") (list1 char)))))) (fn escaped ((cons quote) ((append escaped) quote)))) name)))
(def local-variable-operation.name ((field (symbol local-variable-operation)) (symbol name)))
(def desugar-local-variable-operation (fn operation (desugar-quote (local-variable-operation.name operation))))
(def desugar-global-variable-operation (fn operation (desugar-quote (global-variable-operation.name operation))))
(def desugar-if-operation (fn operation ((concat (symbol "(if ")) ((concat (desugar-operation (if-operation.cond operation))) ((concat (symbol " ")) ((concat (desugar-operation (if-operation.true operation))) ((concat (symbol " ")) ((concat (desugar-operation (if-operation.false operation))) (symbol ")")))))))))
(def desugar-def-operation def-operation.name)
(def fn-operation.arg ((field (symbol fn-operation)) (symbol arg)))
(def desugar-fn-operation (fn operation ((concat (symbol "(fn ")) ((concat (desugar-quote (fn-operation.arg operation))) ((concat (symbol " ")) ((concat (desugar-operation (fn-operation.value operation))) (symbol ")")))))))
(def desugar-impure-operation (fn operation ((concat (symbol "(impure ")) ((concat (desugar-operation (impure-operation.operation operation))) (symbol ")")))))
(def desugar-symbol-operation (fn operation ((concat (symbol "(symbol ")) ((concat (desugar-quote (symbol-operation.name operation))) (symbol ")")))))
(def desugar-apply-operation (fn operation ((concat (symbol "(")) ((concat (desugar-operation (apply-operation.fn operation))) ((concat (symbol " ")) ((concat (desugar-operation (apply-operation.arg operation))) (symbol ")")))))))
(def desugar-line-number-operation (fn operation (desugar-operation (line-number-operation.operation operation))))
(def desugar-nil-operation (const (symbol "()")))
(def desugar-operation (fn operation (((fn type (if ((symbol.= type) (symbol local-variable-operation)) desugar-local-variable-operation (if ((symbol.= type) (symbol global-variable-operation)) desugar-global-variable-operation (if ((symbol.= type) (symbol if-operation)) desugar-if-operation (if ((symbol.= type) (symbol def-operation)) desugar-def-operation (if ((symbol.= type) (symbol fn-operation)) desugar-fn-operation (if ((symbol.= type) (symbol impure-operation)) desugar-impure-operation (if ((symbol.= type) (symbol symbol-operation)) desugar-symbol-operation (if ((symbol.= type) (symbol apply-operation)) desugar-apply-operation (if ((symbol.= type) (symbol line-number-operation)) desugar-line-number-operation (if ((symbol.= type) (symbol nil-operation)) desugar-nil-operation (error (symbol ...))))))))))))) (type-name operation)) operation)))
(def desugar-def-declaration (fn declaration ((concat (symbol "(def ")) ((concat (desugar-quote (def-declaration.name declaration))) ((concat (symbol " ")) ((concat (desugar-operation (def-declaration.value declaration))) ((append (symbol ")")) linefeed)))))))
(def desugar-fn-declaration (const (symbol "")))
(def desugar-declaration (fn declaration (((fn type (if ((symbol.= type) (symbol def-declaration)) desugar-def-declaration (if ((symbol.= type) (symbol fn-declaration)) desugar-fn-declaration (error (symbol ...))))) (type-name declaration)) declaration)))
(def desugar-declarations (fn declarations ((flat-map declarations) desugar-declaration)))
(def sort-declaration-map (fn map (reverse (second (((tree-map.fold map) ((pair (empty-tree-map compare-symbol)) ())) (declaration-dependencies map))))))
(def sort-declarations (fn declarations (sort-declaration-map (declarations->declaration-map declarations))))
(def desugar (fn exprs ((with (generate-env (default-env exprs))) (fn result (desugar-declarations (sort-declarations (generate-result.declarations result)))))))
(def file.write ())
(def desugar-file (fn in (fn out ((then-run-with (generate in)) (fn result ((with (desugar-declarations (sort-declarations (generate-result.declarations result)))) (fn desugared ((file.write out) desugared))))))))
(def dot (car (symbol .)))
(def file.copy ())
(def fn-declaration.closures ((field (symbol fn-declaration)) (symbol closures)))
(def fn-declaration.path ((field (symbol fn-declaration)) (symbol path)))
(def fn-declaration? (is? (symbol fn-declaration)))
(def fn-operation.path ((field (symbol fn-operation)) (symbol path)))
(def global-variable-operation.path ((field (symbol global-variable-operation)) (symbol path)))
(def istream.read (fn istream istream))
(def line-number-operation.line ((field (symbol line-number-operation)) (symbol line)))
(def mpm-put-refs (fn declarations ((with ((filter declarations) def-declaration?)) (fn def-declarations (((fold def-declarations) (impure ())) (fn process (fn declaration ((then-run process) ((file.write ((file.child mpm-ref-root) (normalize (def-declaration.name declaration)))) (def-declaration.path declaration))))))))))
(def mpm-put-srcs (fn in ((file.copy in) mpm-src-root)))
(def mpm-put (fn in ((then-run-with (generate in)) (fn result ((then-run (mpm-put-refs (generate-result.declarations result))) (mpm-put-srcs in))))))
(def nat.- (fn x (fn y (if (nat.0? y) x ((nat.- (nat.dec x)) (nat.dec y))))))
(def nil ())
(def ostream.writeln (fn ostream (fn line (if (nil? line) ((ostream.write ostream) linefeed) ((then-run ((ostream.write ostream) (car line))) ((ostream.writeln ostream) (cdr line)))))))
(def symbol.+ concat)
(def unnormalize id)
