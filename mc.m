(def desugar-nil-operation (fn desugar-operation (fn operation (symbol ""()""))))
(def mangle-fn-name ())
(def interpret-nil-operation (fn interpret-operation' (fn operation (fn stack (fn heap ())))))
(def true (fn x (fn _ x)))
(def false (fn _ (fn x x)))
(def id (fn x x))
(def normalize id)
(def unnormalize id)
(def const (fn x (fn _ x)))
(def desugar-fn-declaration (const ()))
(def compose (fn f (fn g (fn x (f (g x))))))
(def swap (fn f (fn x (fn y ((f y) x)))))
(def apply (fn f (fn x (f x))))
(def with (swap apply))
(def impure (fn x (fn f (f x))))
(def then-run-with (fn p (fn f (p f))))
(def then-run (fn a (fn b ((then-run-with a) (const b)))))
(def run-with (fn p (fn f ((then-run-with p) ((compose impure) f)))))
(def symbol->list id)
(def pair (fn first (fn second (fn bool ((bool first) second)))))
(def first (fn pair (pair true)))
(def type-name first)
(def second (fn pair (pair false)))
(def ostream.write (fn ostream (fn char (ostream char))))
(def unnull (fn either ((either id) id)))
(def left (fn value (fn f (fn _ (f value)))))
(def null (left false))
(def empty-heap (const null))
(def right (fn value (fn _ (fn f (f value)))))
(def some right)
(def left? (fn either ((either (const true)) (const false))))
(def null? left?)
(def right? (fn either ((either (const false)) (const true))))
(def some? right?)
(def nil ())
(def cons pair)
(def car first)
(def cdr second)
(def cddr ((compose cdr) cdr))
(def cdddr ((compose cdr) cddr))
(def cadr ((compose car) cdr))
(def caddr ((compose car) cddr))
(def cadddr ((compose car) cdddr))
(def nil? (fn list ((list (const (const (const false)))) true)))
(def expr.symbol left)
(def expr.list right)
(def list (fn expr (expr.list ((((nil? expr) (const ())) (fn _ ((cons (expr.symbol (symbol cons))) ((cons (car expr)) ((cons ((id list) (cdr expr))) ()))))) ()))))
(def apply-vararg (fn expr (expr.list ((cons (car expr)) ((cons (expr.list ((cons (expr.symbol (symbol list))) (cdr expr)))) ())))))
(def & (fn expr (expr.list ((cons (expr.symbol (symbol and))) ((cons (car expr)) ((cons (expr.list ((cons (expr.symbol (symbol delay))) ((cons (cadr expr)) ())))) ()))))))
(def | (fn expr (expr.list ((cons (expr.symbol (symbol or))) ((cons (car expr)) ((cons (expr.list ((cons (expr.symbol (symbol delay))) ((cons (cadr expr)) ())))) ()))))))
(def if (fn expr (expr.list ((cons (expr.symbol (symbol force))) ((cons (expr.list ((cons (car expr)) ((cons (expr.list ((cons (expr.symbol (symbol delay))) ((cons (cadr expr)) ())))) ((cons (expr.list ((cons (expr.symbol (symbol delay))) ((cons (caddr expr)) ())))) ()))))) ())))))
(def extern (fn expr (expr.list ((cons (expr.symbol (symbol def))) ((cons (car expr)) ((cons (car expr)) ()))))))
(def write-program write-program)
(def mpm-root mpm-root)
(def stdout stdout)
(def stderr stderr)
(def stdin stdin)
(def debug debug)
(def file.local-file file.local-file)
(def file.name file.name)
(def file.name-without-extension file.name-without-extension)
(def file.child file.child)
(def mpm-ref-root ((file.child mpm-root) (symbol ref)))
(def mpm-src-root ((file.child mpm-root) (symbol src)))
(def mpm-get-ref (fn name ((file.child mpm-ref-root) (normalize name))))
(def file.exists? file.exists?)
(def file.read file.read)
(def file.write file.write)
(def file.directory? file.directory?)
(def file.child-files file.child-files)
(def file.copy file.copy)
(def mpm-put-srcs (fn in ((file.copy in) mpm-src-root)))
(def istream.read id)
(def delay (fn expr (expr.list ((cons (expr.symbol (symbol fn))) ((cons (expr.symbol (symbol _))) expr)))))
(def force (fn expr (expr.list ((cons (car expr)) ((cons (right ())) ())))))
(def and (fn x (fn y (((x (fn _ (y ()))) (fn _ false)) ()))))
(def or (fn x (fn y (((x (fn _ true)) (fn _ (y ()))) ()))))
(def not (fn x (((x (fn _ false)) (fn _ true)) ())))
(def heap.+ (fn heap1 (fn heap2 (fn name ((with (heap1 name)) (fn value ((((some? value) (fn _ value)) (fn _ (heap2 name))) ())))))))
(def init (fn list ((((nil? (cdr list)) (fn _ ())) (fn _ ((cons (car list)) (init (cdr list))))) ())))
(def last (fn list ((((nil? (cdr list)) (fn _ (car list))) (fn _ (last (cdr list)))) ())))
(def append (fn list (fn elem ((((nil? list) (fn _ ((cons elem) ()))) (fn _ ((cons (car list)) ((append (cdr list)) elem)))) ()))))
(def concat (fn a (fn b ((((nil? a) (fn _ b)) (fn _ ((cons (car a)) ((concat (cdr a)) b)))) ()))))
(def symbol.+ concat)
(def object (fn type ((pair type) (fn name ((concat (symbol->list (symbol ""Could not find field ""))) ((concat (symbol->list name)) ((concat (symbol->list (symbol "" for ""))) (symbol->list type))))))))
(def nil-operation (object (symbol nil-operation)))
(def tree-map-node-nil (object (symbol tree-map-node-nil)))
(def mpm-get-src (fn ref ((file.child mpm-src-root) ((concat ref) (symbol .m)))))
(def map (fn list (fn f ((((nil? list) (fn _ ())) (fn _ ((cons (f (car list))) ((map (cdr list)) f)))) ()))))
(def flat-map (fn list (fn f ((((nil? list) (fn _ ())) (fn _ ((concat (f (car list))) ((flat-map (cdr list)) f)))) ()))))
(def filter (fn list (fn f ((((nil? list) (fn _ ())) (fn _ ((((f (car list)) (fn _ ((cons (car list)) ((filter (cdr list)) f)))) (fn _ ((filter (cdr list)) f))) ()))) ()))))
(def fold (fn list (fn acc (fn f ((((nil? list) (fn _ acc)) (fn _ (((fold (cdr list)) ((f acc) (car list))) f))) ())))))
(def reverse' (fn list (fn acc ((((nil? list) (fn _ acc)) (fn _ ((reverse' (cdr list)) ((cons (car list)) acc)))) ()))))
(def reverse (fn list ((reverse' list) ())))
(def list.= (fn f (fn a (fn b ((((nil? a) (fn _ (nil? b))) (fn _ ((((nil? b) (fn _ false)) (fn _ ((and ((f (car a)) (car b))) (fn _ (((list.= f) (cdr a)) (cdr b)))))) ()))) ())))))
(def char->nat id)
(def open-parentheses (car (symbol ""("")))
(def close-parentheses (car (symbol "")"")))
(def semicolon (car (symbol "";"")))
(def dot (car (symbol .)))
(def quote (car (symbol """ "")))
(def slash (car (symbol /)))
(def backslash (car (symbol ""\"")))
(def space (car (symbol "" "")))
(def tab (car (symbol ""	"")))
(def linefeed (car (symbol ""
"")))
(def ostream.writeln (fn ostream (fn line ((((nil? line) (fn _ ((ostream.write ostream) linefeed))) (fn _ ((then-run ((ostream.write ostream) (car line))) ((ostream.writeln ostream) (cdr line))))) ()))))
(def carriage-return (car (symbol ""
"")))
(def nat.0 (fn f (fn x x)))
(def nat.1 (fn f (fn x (f x))))
(def nat.0? (fn n ((n (const true)) false)))
(def nat.inc (fn n (fn f (fn x (f ((n f) x))))))
(def nat.dec (fn n (fn f (fn x (((n (fn g (fn h (h (g f))))) (const x)) id)))))
(def get (fn list (fn n ((((nat.0? n) (fn _ (car list))) (fn _ ((get (cdr list)) (nat.dec n)))) ()))))
(def nat.+ (fn a (fn b ((((nat.0? b) (fn _ a)) (fn _ ((nat.+ (nat.inc a)) (nat.dec b)))) ()))))
(def nat.- (fn a (fn b ((((nat.0? b) (fn _ a)) (fn _ ((nat.- (nat.dec a)) (nat.dec b)))) ()))))
(def nat.< (fn a (fn b ((((nat.0? a) (fn _ (not (nat.0? b)))) (fn _ ((((nat.0? b) (fn _ false)) (fn _ ((nat.< (nat.dec a)) (nat.dec b)))) ()))) ()))))
(def nat.> (swap nat.<))
(def nat.= (fn a (fn b ((((nat.0? a) (fn _ (nat.0? b))) (fn _ ((((nat.0? b) (fn _ false)) (fn _ ((nat.= (nat.dec a)) (nat.dec b)))) ()))) ()))))
(def char.= nat.=)
(def symbol.= (list.= char.=))
(def is? (fn type (fn data ((symbol.= type) (type-name data)))))
(def def-declaration? (is? (symbol def-declaration)))
(def fn-declaration? (is? (symbol fn-declaration)))
(def identifier-expr? (is? (symbol identifier-expr)))
(def list-expr? (is? (symbol list-expr)))
(def generating? (is? (symbol generating)))
(def generated? (is? (symbol generated)))
(def degenerate? (is? (symbol degenerate)))
(def local-variable? (is? (symbol local-variable)))
(def global-variable? (is? (symbol global-variable)))
(def tree-map-node-nil? (is? (symbol tree-map-node-nil)))
(def derive (fn data (fn name (fn value ((pair (first data)) (fn field (((((symbol.= field) name) (fn _ value)) (fn _ ((second data) field))) ())))))))
(def data (fn type (fn fields (((fold fields) (object type)) (fn data (fn field (((derive data) (first field)) (second field))))))))
(def new-data' (fn type (fn names (fn fields ((((nil? names) (fn _ ((data type) fields))) (fn _ (fn value (((new-data' type) (cdr names)) ((cons ((pair (car names)) value)) fields))))) ())))))
(def new-data (fn type (fn names (((new-data' type) names) ()))))
(def def-declaration ((new-data (symbol def-declaration)) ((cons (symbol name)) ((cons (symbol path)) ((cons (symbol value)) ())))))
(def fn-declaration ((new-data (symbol fn-declaration)) ((cons (symbol name)) ((cons (symbol path)) ((cons (symbol closures)) ((cons (symbol value)) ()))))))
(def local-env ((new-data (symbol local-env)) ((cons (symbol locals)) ((cons (symbol def)) ()))))
(def global-env ((new-data (symbol global-env)) ((cons (symbol globals)) ((cons (symbol heap)) ((cons (symbol dependents)) ((cons (symbol index)) ()))))))
(def identifier-expr ((new-data (symbol identifier-expr)) ((cons (symbol name)) ((cons (symbol path)) ((cons (symbol start)) ((cons (symbol end)) ()))))))
(def list-expr ((new-data (symbol list-expr)) ((cons (symbol exprs)) ((cons (symbol path)) ((cons (symbol start)) ((cons (symbol end)) ()))))))
(def generating ((new-data (symbol generating)) ((cons (symbol dependencies)) ((cons (symbol global-env)) ((cons (symbol continue)) ())))))
(def generated ((new-data (symbol generated)) ((cons (symbol operation)) ((cons (symbol declarations)) ((cons (symbol global-env)) ())))))
(def generate-nil (fn local-env (fn global-env (((generated nil-operation) ()) global-env))))
(def degenerate ((new-data (symbol degenerate)) ((cons (symbol errors)) ((cons (symbol global-env)) ()))))
(def local-variable-operation ((new-data (symbol local-variable-operation)) ((cons (symbol name)) ((cons (symbol index)) ()))))
(def global-variable-operation ((new-data (symbol global-variable-operation)) ((cons (symbol name)) ((cons (symbol path)) ()))))
(def if-operation ((new-data (symbol if-operation)) ((cons (symbol cond)) ((cons (symbol true)) ((cons (symbol false)) ())))))
(def def-operation ((new-data (symbol def-operation)) ((cons (symbol name)) ((cons (symbol path)) ((cons (symbol value)) ())))))
(def fn-operation ((new-data (symbol fn-operation)) ((cons (symbol path)) ((cons (symbol name)) ((cons (symbol arg)) ((cons (symbol value)) ((cons (symbol closures)) ())))))))
(def symbol-operation ((new-data (symbol symbol-operation)) ((cons (symbol name)) ())))
(def generate-symbol-expr (fn name (fn local-env (fn global-env (((generated (symbol-operation name)) ()) global-env)))))
(def apply-operation ((new-data (symbol apply-operation)) ((cons (symbol fn)) ((cons (symbol arg)) ()))))
(def line-number-operation ((new-data (symbol line-number-operation)) ((cons (symbol operation)) ((cons (symbol line)) ()))))
(def position ((new-data (symbol position)) ((cons (symbol line)) ((cons (symbol char)) ()))))
(def start-position ((position nat.1) nat.1))
(def parse-result ((new-data (symbol parse-result)) ((cons (symbol rest)) ((cons (symbol expr)) ()))))
(def local-variable ((new-data (symbol local-variable)) ((cons (symbol name)) ((cons (symbol index)) ()))))
(def global-variable ((new-data (symbol global-variable)) ((cons (symbol name)) ((cons (symbol path)) ((cons (symbol macro?)) ())))))
(def tree-map-node ((new-data (symbol tree-map-node)) ((cons (symbol left)) ((cons (symbol right)) ((cons (symbol key)) ((cons (symbol value)) ()))))))
(def tree-map ((new-data (symbol tree-map)) ((cons (symbol node)) ((cons (symbol compare)) ()))))
(def empty-tree-map (fn compare ((tree-map tree-map-node-nil) compare)))
(def newline? (fn char ((or ((char.= char) linefeed)) (fn _ ((char.= char) carriage-return)))))
(def parse-comment (fn parse-expr (fn input (fn path (fn position (((((or (nil? input)) (fn _ (newline? (car input)))) (fn _ (((parse-expr input) path) position))) (fn _ ((((parse-comment parse-expr) (cdr input)) path) position))) ()))))))
(def istream.readln (fn istream ((then-run-with istream) (fn char ((((newline? char) (fn _ (impure ()))) (fn _ ((run-with (istream.readln istream)) (fn line ((cons char) line))))) ())))))
(def whitespace? (fn char ((or ((char.= char) space)) (fn _ ((or ((char.= char) tab)) (fn _ (newline? char)))))))
(def separator? (fn char ((or (whitespace? char)) (fn _ ((or ((char.= char) open-parentheses)) (fn _ ((or ((char.= char) close-parentheses)) (fn _ ((or ((char.= char) semicolon)) (fn _ ((char.= char) quote)))))))))))
(def desugar-should-quote? (fn name ((((nil? name) (fn _ false)) (fn _ ((with (car name)) (fn char (((((char.= char) quote) (fn _ true)) (fn _ (((((char.= char) backslash) (fn _ true)) (fn _ (((((char.= char) open-parentheses) (fn _ true)) (fn _ (((((char.= char) close-parentheses) (fn _ true)) (fn _ (((((char.= char) semicolon) (fn _ true)) (fn _ ((((whitespace? char) (fn _ true)) (fn _ (desugar-should-quote? (cdr name)))) ()))) ()))) ()))) ()))) ()))) ()))))) ())))
(def desugar-quote (fn name (((((or (desugar-should-quote? name)) (fn _ (nil? name))) (fn _ ((cons quote) ((cons quote) (((swap append) quote) (((swap append) quote) name)))))) (fn _ name)) ())))
(def compare= (object (symbol compare=)))
(def compare< (object (symbol compare<)))
(def compare> (object (symbol compare>)))
(def compare-nat (fn a (fn b (((((nat.> a) b) (fn _ compare>)) (fn _ (((((nat.< a) b) (fn _ compare<)) (fn _ compare=)) ()))) ()))))
(def compare-char (fn a (fn b ((compare-nat (char->nat a)) (char->nat b)))))
(def compare=? (is? (symbol compare=)))
(def compare-list (fn compare (fn a (fn b (((((and (nil? a)) (fn _ (nil? b))) (fn _ compare=)) (fn _ ((((nil? a) (fn _ compare<)) (fn _ ((((nil? b) (fn _ compare>)) (fn _ ((with ((compare (car a)) (car b))) (fn compare-result ((((compare=? compare-result) (fn _ (((compare-list compare) (cdr a)) (cdr b)))) (fn _ compare-result)) ()))))) ()))) ()))) ())))))
(def compare-symbol (fn a (fn b (((compare-list compare-char) a) b))))
(def default-local-env ((local-env (empty-tree-map compare-symbol)) ()))
(def default-global-env ((((global-env (empty-tree-map compare-symbol)) empty-heap) (empty-tree-map compare-symbol)) nat.0))
(def compare<? (is? (symbol compare<)))
(def compare>? (is? (symbol compare>)))
(def fold-compare (fn compare (fn < (fn > (fn = ((((compare<? compare) (fn _ (< compare))) (fn _ ((((compare>? compare) (fn _ (> compare))) (fn _ (= compare))) ()))) ()))))))
(def error error)
(def heap.get (fn heap (fn name ((with (heap name)) (fn value ((((null? value) (fn _ (error ((concat (symbol->list (symbol ""Could not find ""))) name)))) (fn _ ((unnull value) heap))) ()))))))
(def generate-result.match (fn result (fn degenerate' (fn generating' (fn generated' ((((generated? result) (fn _ (generated' result))) (fn _ ((((generating? result) (fn _ (generating' result))) (fn _ ((((degenerate? result) (fn _ (degenerate' result))) (fn _ (error (symbol ...)))) ()))) ()))) ()))))))
(def as (fn type (fn data (((((is? type) data) (fn _ data)) (fn _ (error ((concat (symbol->list (symbol ""Could not cast ""))) ((concat (symbol->list (type-name data))) ((concat (symbol->list (symbol "" to ""))) (symbol->list type))))))) ()))))
(def field (fn type (fn name (fn data ((second ((as type) data)) name)))))
(def def-declaration.name ((field (symbol def-declaration)) (symbol name)))
(def def-declaration.path ((field (symbol def-declaration)) (symbol path)))
(def mpm-put-refs (fn declarations ((with ((filter declarations) def-declaration?)) (fn def-declarations (((fold def-declarations) (impure ())) (fn process (fn declaration ((then-run process) ((file.write ((file.child mpm-ref-root) (normalize (def-declaration.name declaration)))) (def-declaration.path declaration))))))))))
(def def-declaration.value ((field (symbol def-declaration)) (symbol value)))
(def fn-declaration.name ((field (symbol fn-declaration)) (symbol name)))
(def declaration.name (fn declaration ((((def-declaration? declaration) (fn _ (def-declaration.name declaration))) (fn _ (fn-declaration.name declaration))) ())))
(def fn-declaration.path ((field (symbol fn-declaration)) (symbol path)))
(def fn-declaration.closures ((field (symbol fn-declaration)) (symbol closures)))
(def fn-declaration.value ((field (symbol fn-declaration)) (symbol value)))
(def declaration.value (fn declaration ((((def-declaration? declaration) (fn _ (def-declaration.value declaration))) (fn _ (fn-declaration.value declaration))) ())))
(def local-env.locals ((field (symbol local-env)) (symbol locals)))
(def local-env.with-def (fn def (fn e ((local-env (local-env.locals e)) def))))
(def local-env.def ((field (symbol local-env)) (symbol def)))
(def local-env.with-locals (fn locals (fn e ((local-env locals) (local-env.def e)))))
(def global-env.globals ((field (symbol global-env)) (symbol globals)))
(def global-env.heap ((field (symbol global-env)) (symbol heap)))
(def global-env.dependents ((field (symbol global-env)) (symbol dependents)))
(def global-env.with-index (fn index (fn e ((((global-env (global-env.globals e)) (global-env.heap e)) (global-env.dependents e)) index))))
(def global-env.index ((field (symbol global-env)) (symbol index)))
(def global-env.with-dependents (fn dependents (fn e ((((global-env (global-env.globals e)) (global-env.heap e)) dependents) (global-env.index e)))))
(def global-env.with-heap (fn heap (fn e ((((global-env (global-env.globals e)) heap) (global-env.dependents e)) (global-env.index e)))))
(def global-env.with-globals (fn globals (fn e ((((global-env globals) (global-env.heap e)) (global-env.dependents e)) (global-env.index e)))))
(def identifier-expr.name ((field (symbol identifier-expr)) (symbol name)))
(def identifier-expr.path ((field (symbol identifier-expr)) (symbol path)))
(def identifier-expr.start ((field (symbol identifier-expr)) (symbol start)))
(def identifier-expr.end ((field (symbol identifier-expr)) (symbol end)))
(def list-expr.exprs ((field (symbol list-expr)) (symbol exprs)))
(def expr->list (fn expr ((((identifier-expr? expr) (fn _ (left (identifier-expr.name expr)))) (fn _ (right ((map (list-expr.exprs expr)) expr->list)))) ())))
(def list-expr.path ((field (symbol list-expr)) (symbol path)))
(def expr.path (fn expr ((((list-expr? expr) (fn _ (list-expr.path expr))) (fn _ (identifier-expr.path expr))) ())))
(def list-expr.start ((field (symbol list-expr)) (symbol start)))
(def expr.start (fn expr ((((list-expr? expr) (fn _ (list-expr.start expr))) (fn _ (identifier-expr.start expr))) ())))
(def list-expr.end ((field (symbol list-expr)) (symbol end)))
(def expr.end (fn expr ((((list-expr? expr) (fn _ (list-expr.end expr))) (fn _ (identifier-expr.end expr))) ())))
(def list->expr (fn expr (fn either ((either (fn name ((((identifier-expr name) (expr.path expr)) (expr.start expr)) (expr.end expr)))) (fn list ((((list-expr ((map list) (list->expr expr))) (expr.path expr)) (expr.start expr)) (expr.end expr)))))))
(def generate-macro-apply-expr (fn generate-expr (fn expr (fn name (fn args (fn local-env (fn global-env ((with ((heap.get (global-env.heap global-env)) name)) (fn function (((generate-expr ((list->expr expr) (function ((map args) expr->list)))) local-env) global-env))))))))))
(def generate-if-expr (fn generate-expr (fn cond-expr (fn true-expr (fn false-expr (fn local-env (fn global-env (((generate-expr ((((list-expr ((cons ((((list-expr ((cons cond-expr) ((cons ((((list-expr ((cons ((((identifier-expr (symbol fn)) (expr.path true-expr)) (expr.start true-expr)) (expr.end true-expr))) ((cons ((((identifier-expr ()) (expr.path true-expr)) (expr.start true-expr)) (expr.end true-expr))) ((cons true-expr) ())))) (expr.path true-expr)) (expr.start true-expr)) (expr.end true-expr))) ((cons ((((list-expr ((cons ((((identifier-expr (symbol fn)) (expr.path false-expr)) (expr.start false-expr)) (expr.end false-expr))) ((cons ((((identifier-expr ()) (expr.path false-expr)) (expr.start false-expr)) (expr.end false-expr))) ((cons false-expr) ())))) (expr.path false-expr)) (expr.start false-expr)) (expr.end false-expr))) ())))) (expr.path cond-expr)) (expr.start cond-expr)) (expr.end cond-expr))) ((cons ((((list-expr ()) (expr.path cond-expr)) (expr.start cond-expr)) (expr.start cond-expr))) ()))) (expr.path cond-expr)) (expr.start cond-expr)) (expr.end cond-expr))) local-env) global-env))))))))
(def generating.dependencies ((field (symbol generating)) (symbol dependencies)))
(def generating.global-env ((field (symbol generating)) (symbol global-env)))
(def generating.continue ((field (symbol generating)) (symbol continue)))
(def generated-resolve-generating (fn generated.combine (fn generated' (fn generating' (fn global-env (fn f (((generating (generating.dependencies generating')) global-env) (fn global-env ((((generated.combine generated') ((generating.continue generating') global-env)) global-env) f)))))))))
(def generated.operation ((field (symbol generated)) (symbol operation)))
(def generated.declarations ((field (symbol generated)) (symbol declarations)))
(def write-result (fn result (fn out (((write-program out) (generated.operation result)) (generated.declarations result)))))
(def generated.global-env ((field (symbol generated)) (symbol global-env)))
(def degenerate.errors ((field (symbol degenerate)) (symbol errors)))
(def degenerate.with-global-env (fn env (fn degenerate' ((degenerate (degenerate.errors degenerate')) env))))
(def generated.combine (fn generated1 (fn result (fn global-env (fn f ((((generate-result.match result) (fn degenerate2 ((degenerate.with-global-env global-env) degenerate2))) (fn generating2 (((((generated-resolve-generating generated.combine) generated1) generating2) global-env) f))) (fn generated2 (((generated ((f (generated.operation generated1)) (generated.operation generated2))) ((concat (generated.declarations generated1)) (generated.declarations generated2))) global-env))))))))
(def generating.combine (fn generating1 (fn result (fn global-env (fn f ((((generate-result.match result) (fn degenerate2 ((degenerate.with-global-env global-env) degenerate2))) (fn generating2 (((generating ((concat (generating.dependencies generating1)) (generating.dependencies generating2))) global-env) (fn global-env ((((generating.combine generating1) generating2) global-env) f))))) (fn generated2 (((((generated-resolve-generating generated.combine) generated2) generating1) global-env) (swap f)))))))))
(def degenerate.combine (fn degenerate1 (fn result (fn global-env (fn f ((((generate-result.match result) (fn degenerate2 ((degenerate ((concat (degenerate.errors degenerate1)) (degenerate.errors degenerate2))) global-env))) (fn generating2 ((degenerate.with-global-env global-env) degenerate1))) (fn generated2 ((degenerate.with-global-env global-env) degenerate1))))))))
(def generate-result.combine (fn result1 (fn result2 (fn global-env (fn f ((((generate-result.match result1) (fn degenerate1 ((((degenerate.combine degenerate1) result2) global-env) f))) (fn generating1 ((((generating.combine generating1) result2) global-env) f))) (fn generated1 ((((generated.combine generated1) result2) global-env) f))))))))
(def degenerate.global-env ((field (symbol degenerate)) (symbol global-env)))
(def generate-result.global-env (fn result ((((generate-result.match result) degenerate.global-env) generating.global-env) generated.global-env)))
(def generate-apply-expr' (fn fn-result (fn arg-result ((((generate-result.combine fn-result) arg-result) (generate-result.global-env arg-result)) apply-operation))))
(def generate-apply-expr (fn generate-expr (fn fn (fn args (fn local-env (fn global-env ((with (((generate-expr fn) local-env) global-env)) (fn fn-result (((fold args) fn-result) (fn fn-result (fn arg ((with (((generate-expr arg) local-env) (generate-result.global-env fn-result))) (fn arg-result ((generate-apply-expr' fn-result) arg-result))))))))))))))
(def local-variable-operation.name ((field (symbol local-variable-operation)) (symbol name)))
(def desugar-local-variable-operation (fn desugar-operation (fn operation (desugar-quote (local-variable-operation.name operation)))))
(def local-variable-operation.index ((field (symbol local-variable-operation)) (symbol index)))
(def interpret-local-variable-operation (fn interpret-operation' (fn operation (fn stack (fn heap ((get stack) (local-variable-operation.index operation)))))))
(def global-variable-operation.name ((field (symbol global-variable-operation)) (symbol name)))
(def desugar-global-variable-operation (fn desugar-operation (fn operation (desugar-quote (global-variable-operation.name operation)))))
(def interpret-global-variable-operation (fn interpret-operation' (fn operation (fn stack (fn heap ((heap.get heap) (global-variable-operation.name operation)))))))
(def global-variable-operation.path ((field (symbol global-variable-operation)) (symbol path)))
(def if-operation.cond ((field (symbol if-operation)) (symbol cond)))
(def if-operation.true ((field (symbol if-operation)) (symbol true)))
(def if-operation.false ((field (symbol if-operation)) (symbol false)))
(def interpret-if-operation (fn interpret-operation' (fn operation (fn stack (fn heap ((((((interpret-operation' (if-operation.cond operation)) stack) heap) (fn _ (((interpret-operation' (if-operation.true operation)) stack) heap))) (fn _ (((interpret-operation' (if-operation.false operation)) stack) heap))) ()))))))
(def def-operation.name ((field (symbol def-operation)) (symbol name)))
(def desugar-def-operation (fn desugar-operation (fn operation (def-operation.name operation))))
(def interpret-def-operation (fn interpret-operation' (fn operation (fn stack (fn heap ((heap.get heap) (def-operation.name operation)))))))
(def def-operation.path ((field (symbol def-operation)) (symbol path)))
(def def-operation.value ((field (symbol def-operation)) (symbol value)))
(def fn-operation.path ((field (symbol fn-operation)) (symbol path)))
(def fn-operation.name ((field (symbol fn-operation)) (symbol name)))
(def fn-operation.arg ((field (symbol fn-operation)) (symbol arg)))
(def fn-operation.value ((field (symbol fn-operation)) (symbol value)))
(def desugar-fn-operation (fn desugar-operation (fn operation ((concat (symbol ""(fn "")) ((concat (desugar-quote (fn-operation.arg operation))) ((concat (symbol "" "")) ((concat (desugar-operation (fn-operation.value operation))) (symbol "")""))))))))
(def fn-operation.closures ((field (symbol fn-operation)) (symbol closures)))
(def interpret-fn-operation (fn interpret-operation' (fn operation (fn stack (fn heap (fn arg (((heap.get heap) (fn-operation.name operation)) ((concat ((map (fn-operation.closures operation)) (fn closure (((interpret-operation' closure) stack) heap)))) ((cons arg) stack)))))))))
(def symbol-operation.name ((field (symbol symbol-operation)) (symbol name)))
(def interpret-symbol-operation (fn interpret-operation' (fn operation (fn stack (fn heap (symbol-operation.name operation))))))
(def desugar-symbol-operation (fn desugar-operation (fn operation ((concat (symbol ""(symbol "")) ((concat (desugar-quote (symbol-operation.name operation))) (symbol "")""))))))
(def apply-operation.fn ((field (symbol apply-operation)) (symbol fn)))
(def apply-operation.arg ((field (symbol apply-operation)) (symbol arg)))
(def interpret-apply-operation (fn interpret-operation' (fn operation (fn stack (fn heap ((((interpret-operation' (apply-operation.fn operation)) stack) heap) (((interpret-operation' (apply-operation.arg operation)) stack) heap)))))))
(def desugar-apply-operation (fn desugar-operation (fn operation ((concat (symbol ""("")) ((concat (desugar-operation (apply-operation.fn operation))) ((concat (symbol "" "")) ((concat (desugar-operation (apply-operation.arg operation))) (symbol "")""))))))))
(def line-number-operation.operation ((field (symbol line-number-operation)) (symbol operation)))
(def desugar-line-number-operation (fn desugar-operation (fn operation (desugar-operation (line-number-operation.operation operation)))))
(def desugar-operation (fn operation ((((fn type (((((symbol.= type) (symbol local-variable-operation)) (fn _ desugar-local-variable-operation)) (fn _ (((((symbol.= type) (symbol global-variable-operation)) (fn _ desugar-global-variable-operation)) (fn _ (((((symbol.= type) (symbol def-operation)) (fn _ desugar-def-operation)) (fn _ (((((symbol.= type) (symbol fn-operation)) (fn _ desugar-fn-operation)) (fn _ (((((symbol.= type) (symbol symbol-operation)) (fn _ desugar-symbol-operation)) (fn _ (((((symbol.= type) (symbol apply-operation)) (fn _ desugar-apply-operation)) (fn _ (((((symbol.= type) (symbol line-number-operation)) (fn _ desugar-line-number-operation)) (fn _ (((((symbol.= type) (symbol nil-operation)) (fn _ desugar-nil-operation)) (fn _ (error (symbol ...)))) ()))) ()))) ()))) ()))) ()))) ()))) ()))) ())) (type-name operation)) desugar-operation) operation)))
(def desugar-def-declaration (fn declaration ((concat (symbol ""(def "")) ((concat (desugar-quote (def-declaration.name declaration))) ((concat (symbol "" "")) ((concat (desugar-operation (def-declaration.value declaration))) ((append (symbol "")"")) linefeed)))))))
(def desugar-declaration (fn declaration (((fn type (((((symbol.= type) (symbol def-declaration)) (fn _ desugar-def-declaration)) (fn _ (((((symbol.= type) (symbol fn-declaration)) (fn _ desugar-fn-declaration)) (fn _ (error (symbol ...)))) ()))) ())) (type-name declaration)) declaration)))
(def desugar-declarations (fn declarations ((flat-map declarations) desugar-declaration)))
(def interpret-line-number-operation (fn interpret-operation' (fn operation (interpret-operation' (line-number-operation.operation operation)))))
(def interpret-operation' (fn operation (fn stack (fn heap ((((((with (type-name operation)) (fn type (((((symbol.= type) (symbol local-variable-operation)) (fn _ interpret-local-variable-operation)) (fn _ (((((symbol.= type) (symbol global-variable-operation)) (fn _ interpret-global-variable-operation)) (fn _ (((((symbol.= type) (symbol if-operation)) (fn _ interpret-if-operation)) (fn _ (((((symbol.= type) (symbol def-operation)) (fn _ interpret-def-operation)) (fn _ (((((symbol.= type) (symbol fn-operation)) (fn _ interpret-fn-operation)) (fn _ (((((symbol.= type) (symbol symbol-operation)) (fn _ interpret-symbol-operation)) (fn _ (((((symbol.= type) (symbol apply-operation)) (fn _ interpret-apply-operation)) (fn _ (((((symbol.= type) (symbol line-number-operation)) (fn _ interpret-line-number-operation)) (fn _ (((((symbol.= type) (symbol nil-operation)) (fn _ interpret-nil-operation)) (fn _ (error (symbol ...)))) ()))) ()))) ()))) ()))) ()))) ()))) ()))) ()))) ()))) interpret-operation') operation) stack) heap)))))
(def interpret-operation (fn operation (fn heap (((interpret-operation' operation) ()) heap))))
(def repl-interpret-operation (fn result (fn heap ((interpret-operation (generated.operation result)) heap))))
(def interpret-def-declaration (fn declaration (fn heap (fn name (((((symbol.= name) (def-declaration.name declaration)) (fn _ (some (fn heap' ((interpret-operation (def-declaration.value declaration)) heap'))))) (fn _ (heap name))) ())))))
(def interpret-fn-declaration (fn declaration (fn heap (fn name (((((symbol.= name) (fn-declaration.name declaration)) (fn _ (some (fn heap' (fn stack (((interpret-operation' (fn-declaration.value declaration)) stack) heap')))))) (fn _ (heap name))) ())))))
(def interpret-declaration (fn declaration (fn heap (((((with (type-name declaration)) (fn type (((((symbol.= type) (symbol def-declaration)) (fn _ interpret-def-declaration)) (fn _ (((((symbol.= type) (symbol fn-declaration)) (fn _ interpret-fn-declaration)) (fn _ (error (symbol ...)))) ()))) ()))) (type-name declaration)) declaration) heap))))
(def interpret-declarations (fn declarations (fn heap (((fold declarations) heap) (fn heap' (fn declaration ((interpret-declaration declaration) heap')))))))
(def repl-interpret-declarations (fn result (fn heap ((interpret-declarations (generated.declarations result)) heap))))
(def operation.fold (fn operation (fn acc (fn f ((f ((with (type-name operation)) (fn type (((((symbol.= type) (symbol local-variable-operation)) (fn _ acc)) (fn _ (((((symbol.= type) (symbol global-variable-operation)) (fn _ acc)) (fn _ (((((symbol.= type) (symbol if-operation)) (fn _ (((operation.fold (if-operation.false operation)) (((operation.fold (if-operation.true operation)) (((operation.fold (if-operation.cond operation)) acc) f)) f)) f))) (fn _ (((((symbol.= type) (symbol def-operation)) (fn _ (((operation.fold (def-operation.value operation)) acc) f))) (fn _ (((((symbol.= type) (symbol fn-operation)) (fn _ (((operation.fold (fn-operation.value operation)) acc) f))) (fn _ (((((symbol.= type) (symbol symbol-operation)) (fn _ acc)) (fn _ (((((symbol.= type) (symbol apply-operation)) (fn _ (((operation.fold (apply-operation.arg operation)) (((operation.fold (apply-operation.fn operation)) acc) f)) f))) (fn _ (((((symbol.= type) (symbol line-number-operation)) (fn _ (((operation.fold (line-number-operation.operation operation)) acc) f))) (fn _ (((((symbol.= type) (symbol nil-operation)) (fn _ acc)) (fn _ (error (symbol ...)))) ()))) ()))) ()))) ()))) ()))) ()))) ()))) ()))) ())))) operation)))))
(def line-number-operation.line ((field (symbol line-number-operation)) (symbol line)))
(def position.line ((field (symbol position)) (symbol line)))
(def next-line (fn p ((position ((nat.+ nat.1) (position.line p))) nat.1)))
(def position.char ((field (symbol position)) (symbol char)))
(def next-char (fn p ((position (position.line p)) ((nat.+ nat.1) (position.char p)))))
(def parse-single-quote (fn input (fn path (fn start (fn end (fn acc ((with (car input)) (fn head (((((char.= head) quote) (fn _ ((parse-result (cdr input)) ((((identifier-expr (reverse acc)) path) start) (next-char end))))) (fn _ ((((newline? head) (fn _ (((((parse-single-quote (cdr input)) path) start) (next-line end)) ((cons head) acc)))) (fn _ (((((parse-single-quote (cdr input)) path) start) (next-char end)) ((cons head) acc)))) ()))) ())))))))))
(def parse-double-quote (fn input (fn path (fn start (fn end (fn acc ((with (car input)) (fn head (((((char.= head) quote) (fn _ (((((char.= (cadr input)) quote) (fn _ ((parse-result (cddr input)) ((((identifier-expr (reverse acc)) path) start) (next-char (next-char end)))))) (fn _ (((((parse-double-quote (cdr input)) path) start) (next-char end)) ((cons quote) acc)))) ()))) (fn _ ((((newline? head) (fn _ (((((parse-double-quote (cdr input)) path) start) (next-line end)) ((cons head) acc)))) (fn _ (((((parse-double-quote (cdr input)) path) start) (next-char end)) ((cons head) acc)))) ()))) ())))))))))
(def parse-identifier-literal-expr (fn input (fn path (fn start (fn end (fn acc (((((char.= (car input)) quote) (fn _ (((((parse-double-quote (cdr input)) path) start) (next-char end)) acc))) (fn _ (((((parse-single-quote input) path) start) end) acc))) ())))))))
(def parse-identifier-expr (fn input (fn path (fn start (fn end (fn acc ((((separator? (car input)) (fn _ ((parse-result input) ((((identifier-expr (reverse acc)) path) start) end)))) (fn _ (((((parse-identifier-expr (cdr input)) path) start) (next-char end)) ((cons (car input)) acc)))) ())))))))
(def parse-result.rest ((field (symbol parse-result)) (symbol rest)))
(def parse-result.expr ((field (symbol parse-result)) (symbol expr)))
(def parse-list-expr (fn parse-expr (fn input (fn path (fn start (fn end (fn acc (((((char.= (car input)) close-parentheses) (fn _ ((parse-result (cdr input)) ((((list-expr (reverse acc)) path) start) end)))) (fn _ ((with (((parse-expr input) path) end)) (fn result ((((((parse-list-expr parse-expr) (parse-result.rest result)) path) start) (expr.end (parse-result.expr result))) ((cons (parse-result.expr result)) acc)))))) ()))))))))
(def parse-expr (fn input (fn path (fn position ((with (car input)) (fn head (((((char.= head) open-parentheses) (fn _ ((((((parse-list-expr parse-expr) (cdr input)) path) (next-char position)) (next-char position)) ()))) (fn _ (((((char.= head) quote) (fn _ (((((parse-identifier-literal-expr (cdr input)) path) (next-char position)) (next-char position)) ()))) (fn _ (((((char.= head) semicolon) (fn _ ((((parse-comment parse-expr) (cdr input)) path) (next-char position)))) (fn _ (((((char.= head) linefeed) (fn _ (((parse-expr (cdr input)) path) (next-line position)))) (fn _ ((((whitespace? head) (fn _ (((parse-expr (cdr input)) path) (next-char position)))) (fn _ (((((parse-identifier-expr input) path) position) position) ()))) ()))) ()))) ()))) ()))) ())))))))
(def parse (fn input (fn path (fn position (fn acc ((((nil? input) (fn _ (reverse acc))) (fn _ (((((char.= linefeed) (car input)) (fn _ ((((parse (cdr input)) path) (next-line position)) acc))) (fn _ ((((whitespace? (car input)) (fn _ ((((parse (cdr input)) path) (next-char position)) acc))) (fn _ ((with (((parse-expr input) path) position)) (fn result ((((parse (parse-result.rest result)) path) (expr.end (parse-result.expr result))) ((cons (parse-result.expr result)) acc)))))) ()))) ()))) ()))))))
(def parse-file (fn file (fn path (fn init ((then-run-with (file.directory? file)) (fn directory? (((directory? (fn _ ((then-run-with (file.child-files file)) (fn child-files (((fold child-files) (impure ())) (fn acc (fn child ((then-run-with (((parse-file child) (((init (fn _ ())) (fn _ ((concat path) ((append (file.name file)) slash)))) ())) false)) (fn parse ((run-with acc) (fn exprs ((concat exprs) parse)))))))))))) (fn _ ((run-with (file.read file)) (fn chars ((((parse chars) ((concat path) (file.name-without-extension file))) ((position nat.1) nat.1)) ()))))) ())))))))
(def repl-parse (fn line (fn index (parse-result.expr (((parse-expr ((append line) linefeed)) ((mangle-fn-name (symbol repl)) index)) ((position index) nat.1))))))
(def local-variable.name ((field (symbol local-variable)) (symbol name)))
(def local-variable.index ((field (symbol local-variable)) (symbol index)))
(def global-variable.name ((field (symbol global-variable)) (symbol name)))
(def global-variable.path ((field (symbol global-variable)) (symbol path)))
(def generate-identifier-expr' (fn variable ((((global-variable? variable) (fn _ ((global-variable-operation (global-variable.name variable)) (global-variable.path variable)))) (fn _ ((local-variable-operation (local-variable.name variable)) (local-variable.index variable)))) ())))
(def global-variable.macro? ((field (symbol global-variable)) (symbol macro?)))
(def tree-map-node.left ((field (symbol tree-map-node)) (symbol left)))
(def tree-map-node.min-node (fn node ((((tree-map-node-nil? (tree-map-node.left node)) (fn _ node)) (fn _ (tree-map-node.min-node (tree-map-node.left node)))) ())))
(def tree-map-node.right ((field (symbol tree-map-node)) (symbol right)))
(def tree-map-node.key ((field (symbol tree-map-node)) (symbol key)))
(def tree-map-node.value ((field (symbol tree-map-node)) (symbol value)))
(def tree-map-node.get (fn node (fn compare (fn key ((((tree-map-node-nil? node) (fn _ null)) (fn _ ((((fold-compare ((compare key) (tree-map-node.key node))) (fn < (((tree-map-node.get (tree-map-node.left node)) compare) key))) (fn > (((tree-map-node.get (tree-map-node.right node)) compare) key))) (fn = (some (tree-map-node.value node)))))) ())))))
(def tree-map-node.remove (fn node (fn compare (fn key ((((tree-map-node-nil? node) (fn _ node)) (fn _ ((((fold-compare ((compare key) (tree-map-node.key node))) (fn < ((((tree-map-node (((tree-map-node.remove (tree-map-node.left node)) compare) key)) (tree-map-node.right node)) (tree-map-node.key node)) (tree-map-node.value node)))) (fn > ((((tree-map-node (tree-map-node.left node)) (((tree-map-node.remove (tree-map-node.right node)) compare) key)) (tree-map-node.key node)) (tree-map-node.value node)))) (fn = ((((tree-map-node-nil? (tree-map-node.left node)) (fn _ (tree-map-node.right node))) (fn _ ((((tree-map-node-nil? (tree-map-node.right node)) (fn _ (tree-map-node.left node))) (fn _ ((with (tree-map-node.min-node (tree-map-node.right node))) (fn min ((((tree-map-node (tree-map-node.left node)) (tree-map-node.right (((tree-map-node.remove (tree-map-node.right node)) compare) key))) (tree-map-node.key min)) (tree-map-node.value min)))))) ()))) ()))))) ())))))
(def tree-map-node.put (fn node (fn compare (fn key (fn value ((((tree-map-node-nil? node) (fn _ ((((tree-map-node tree-map-node-nil) tree-map-node-nil) key) value))) (fn _ ((((fold-compare ((compare key) (tree-map-node.key node))) (fn < ((((tree-map-node ((((tree-map-node.put (tree-map-node.left node)) compare) key) value)) (tree-map-node.right node)) (tree-map-node.key node)) (tree-map-node.value node)))) (fn > ((((tree-map-node (tree-map-node.left node)) ((((tree-map-node.put (tree-map-node.right node)) compare) key) value)) (tree-map-node.key node)) (tree-map-node.value node)))) (fn = ((((tree-map-node (tree-map-node.left node)) (tree-map-node.right node)) key) value))))) ()))))))
(def tree-map-node.fold (fn node (fn acc (fn f ((((tree-map-node-nil? node) (fn _ acc)) (fn _ (((tree-map-node.fold (tree-map-node.right node)) (((f (((tree-map-node.fold (tree-map-node.left node)) acc) f)) (tree-map-node.key node)) (tree-map-node.value node))) f))) ())))))
(def tree-map.node ((field (symbol tree-map)) (symbol node)))
(def tree-map.fold (fn map (fn acc (fn f (((tree-map-node.fold (tree-map.node map)) acc) f)))))
(def tree-map->list (fn map (((tree-map.fold map) ()) (fn list (fn key (fn value ((cons ((pair key) value)) list)))))))
(def tree-map.compare ((field (symbol tree-map)) (symbol compare)))
(def tree-map.get (fn map (fn key (((tree-map-node.get (tree-map.node map)) (tree-map.compare map)) key))))
(def env.get (fn local-env (fn global-env (fn name ((with ((tree-map.get (local-env.locals local-env)) name)) (fn option ((((some? option) (fn _ option)) (fn _ ((tree-map.get (global-env.globals global-env)) name))) ())))))))
(def generate-identifier-expr (fn name (fn local-env (fn global-env ((with (((env.get local-env) global-env) name)) (fn option ((((some? option) (fn _ (((generated (generate-identifier-expr' (unnull option))) ()) global-env))) (fn _ (((generating ((cons name) ())) global-env) (fn global-env (((generate-identifier-expr name) local-env) global-env))))) ())))))))
(def generate-macro?-expr (fn generate-expr (fn expr (fn fn (fn args (fn local-env (fn global-env ((with (identifier-expr.name fn)) (fn name ((with (((env.get local-env) global-env) name)) (fn option ((((null? option) (fn _ (((generating ((cons name) ())) global-env) (fn global-env (((((generate-macro?-expr expr) fn) args) local-env) global-env))))) (fn _ ((with (unnull option)) (fn variable (((((and (global-variable? variable)) (fn _ (global-variable.macro? variable))) (fn _ ((((((generate-macro-apply-expr generate-expr) expr) name) args) local-env) global-env))) (fn _ (((((generate-apply-expr generate-expr) fn) args) local-env) global-env))) ()))))) ()))))))))))))
(def global-env.unresolved (fn global-env ((filter ((map (tree-map->list (global-env.dependents global-env))) first)) (fn dependent (null? ((tree-map.get (global-env.globals global-env)) dependent))))))
(def tree-map.remove (fn map (fn key ((tree-map (((tree-map-node.remove (tree-map.node map)) (tree-map.compare map)) key)) (tree-map.compare map)))))
(def tree-map.put (fn map (fn key (fn value ((tree-map ((((tree-map-node.put (tree-map.node map)) (tree-map.compare map)) key) value)) (tree-map.compare map))))))
(def generate-fn-expr-closures (fn closures (fn name (fn local-env (second (((fold ((append closures) name)) ((pair nat.0) (local-env.locals local-env))) (fn vars (fn closure ((pair ((nat.+ nat.1) (first vars))) (((tree-map.put (second vars)) closure) ((local-variable closure) (first vars))))))))))))
(def generating->generated (fn generating' (fn operation (fn global-env (fn continue (((generated operation) ()) (((swap global-env.with-dependents) global-env) ((with (global-env.dependents (generating.global-env generating'))) (fn dependents ((with (car (generating.dependencies generating'))) (fn dependency (((tree-map.put dependents) dependency) (fn global-env ((((null? ((tree-map.get dependents) dependency)) (fn _ (continue global-env))) (fn _ ((with ((unnull ((tree-map.get dependents) dependency)) global-env)) (fn result1 ((with (continue (generate-result.global-env result1))) (fn result2 ((((generate-result.combine result1) result2) (generate-result.global-env result2)) false))))))) ()))))))))))))))
(def tree-map.+ (fn a (fn b (((tree-map.fold a) b) (fn map (fn key (fn value (((tree-map.put map) key) value))))))))
(def generate-global-expr (fn macro? (fn generate-expr (fn name (fn value (fn local-env (fn global-env ((((some? ((tree-map.get (global-env.globals global-env)) name)) (fn _ ((degenerate ((cons ((concat name) (symbol "" has already been defined""))) ())) global-env))) (fn _ ((with (((swap global-env.with-globals) global-env) (((tree-map.put (global-env.globals global-env)) name) (((global-variable name) (expr.path value)) macro?)))) (fn new-global-env ((((generate-result.match (((generate-expr value) ((local-env.with-def name) local-env)) new-global-env)) (fn degenerate' degenerate')) (fn generating' ((((generating->generated generating') (((def-operation name) (expr.path value)) nil-operation)) global-env) (fn global-env ((((((generate-global-expr macro?) generate-expr) name) value) local-env) global-env))))) (fn generated' ((with (((def-declaration name) (expr.path value)) (generated.operation generated'))) (fn declaration ((with ((tree-map.get (global-env.dependents (generated.global-env generated'))) name)) (fn generating? ((with (((generated (((def-operation name) (expr.path value)) (generated.operation generated'))) ((append (generated.declarations generated')) declaration)) (((swap global-env.with-heap) (generated.global-env generated')) ((interpret-def-declaration declaration) (global-env.heap (generated.global-env generated')))))) (fn result1 ((((null? generating?) (fn _ result1)) (fn _ ((with ((unnull generating?) (generated.global-env result1))) (fn result2 ((((generated.combine result1) result2) (generate-result.global-env result2)) true))))) ()))))))))))))) ()))))))))
(def generate-def-expr (generate-global-expr false))
(def generate-macro-expr (generate-global-expr true))
(def closures' (fn local-env (fn acc (fn expr ((((identifier-expr? expr) (fn _ ((((null? ((tree-map.get (local-env.locals local-env)) (identifier-expr.name expr))) (fn _ acc)) (fn _ (((tree-map.put acc) (identifier-expr.name expr)) true))) ()))) (fn _ (((fold (list-expr.exprs expr)) acc) (closures' local-env)))) ())))))
(def closures (fn local-env ((closures' local-env) (empty-tree-map compare-symbol))))
(def generate-fn-expr' (fn generate-expr (fn name (fn value (fn local-env (fn global-env ((with ((mangle-fn-name (local-env.def local-env)) (global-env.index global-env))) (fn mangled-name ((with ((global-env.with-index ((nat.+ nat.1) (global-env.index global-env))) global-env)) (fn new-global-env ((with ((map (tree-map->list ((closures local-env) value))) first)) (fn closures ((((generate-result.match (((generate-expr value) ((local-env.with-locals (((generate-fn-expr-closures closures) name) local-env)) ((local-env.with-def mangled-name) local-env))) new-global-env)) (fn degenerate' degenerate')) (fn generating' (((generating (generating.dependencies generating')) (generating.global-env generating')) (fn global-env ((((generate-fn-expr' name) value) local-env) global-env))))) (fn generated' ((with ((((fn-declaration mangled-name) (expr.path value)) closures) (generated.operation generated'))) (fn declaration (((generated (((((fn-operation (expr.path value)) mangled-name) name) (generated.operation generated')) ((map closures) (fn closure (generate-identifier-expr' (unnull (((env.get local-env) (generated.global-env generated')) closure))))))) ((append (generated.declarations generated')) declaration)) (((swap global-env.with-heap) (generated.global-env generated')) ((interpret-fn-declaration declaration) (global-env.heap (generated.global-env generated')))))))))))))))))))))
(def generate-fn-expr (fn generate-expr (fn names (fn value (fn local-env (fn global-env ((((nil? (cdr names)) (fn _ (((((generate-fn-expr' generate-expr) (car names)) value) local-env) global-env))) (fn _ ((with ((((list-expr ((cons ((((identifier-expr (symbol fn)) (expr.path value)) (expr.start value)) (expr.end value))) ((cons ((((identifier-expr (last names)) (expr.path value)) (expr.start value)) (expr.end value))) ((cons value) ())))) (expr.path value)) (expr.start value)) (expr.end value))) (fn new-value (((((generate-fn-expr generate-expr) (init names)) new-value) local-env) global-env))))) ())))))))
(def generate-list-expr (fn generate-expr (fn expr (fn local-env (fn global-env ((with (list-expr.exprs expr)) (fn exprs ((((nil? exprs) (fn _ ((generate-nil local-env) global-env))) (fn _ ((((identifier-expr? (car exprs)) (fn _ ((with (identifier-expr.name (car exprs))) (fn name ((((((list.= char.=) name) (symbol->list (symbol fn))) (fn _ (((((generate-fn-expr generate-expr) ((map (init (cdr exprs))) identifier-expr.name)) (last exprs)) local-env) global-env))) (fn _ ((((((list.= char.=) name) (symbol->list (symbol def))) (fn _ (((((generate-def-expr generate-expr) (identifier-expr.name (cadr exprs))) (caddr exprs)) local-env) global-env))) (fn _ ((((((list.= char.=) name) (symbol->list (symbol macro))) (fn _ (((((generate-macro-expr generate-expr) (identifier-expr.name (cadr exprs))) (caddr exprs)) local-env) global-env))) (fn _ ((((((list.= char.=) name) (symbol->list (symbol symbol))) (fn _ (((generate-symbol-expr (identifier-expr.name (cadr exprs))) local-env) global-env))) (fn _ ((((((generate-macro?-expr generate-expr) expr) (car exprs)) (cdr exprs)) local-env) global-env))) ()))) ()))) ()))) ()))))) (fn _ (((((generate-apply-expr generate-expr) (car exprs)) (cdr exprs)) local-env) global-env))) ()))) ()))))))))
(def generate-expr (fn expr (fn local-env (fn global-env ((((generate-result.match ((((identifier-expr? expr) (fn _ (((generate-identifier-expr (identifier-expr.name expr)) local-env) global-env))) (fn _ ((((generate-list-expr generate-expr) expr) local-env) global-env))) ())) (fn degenerate' degenerate')) (fn generating' generating')) (fn generated' (((generated ((line-number-operation (generated.operation generated')) (position.line (expr.start expr)))) (generated.declarations generated')) (generated.global-env generated'))))))))
(def generate-exprs' (fn exprs (fn result ((((nil? exprs) (fn _ result)) (fn _ ((with ((((generate-result.match (((generate-expr (car exprs)) default-local-env) (generate-result.global-env result))) (fn degenerate' degenerate')) (fn generating' ((((generating->generated generating') nil-operation) (generate-result.global-env result)) (fn global-env (((generate-expr (car exprs)) default-local-env) global-env))))) (fn generated' generated'))) (fn car-result ((generate-exprs' (cdr exprs)) ((((generate-result.combine result) car-result) (generate-result.global-env car-result)) true)))))) ()))))
(def generate-exprs (fn exprs (fn global-env ((generate-exprs' exprs) (((generated nil-operation) ()) global-env)))))
(def mpm-resolve-dependencies (fn resolve (fn resolved (fn result (fn dependencies (fn indef ((((nil? dependencies) (fn _ ((with (((indef (fn _ result)) (fn _ ((degenerate ((symbol.+ (symbol ""Could not find "")) ((flat-map dependencies) ((swap append) space)))) (generate-result.global-env result)))) ())) (fn result (impure ((pair resolved) result)))))) (fn _ ((with (mpm-get-ref (car dependencies))) (fn ref-file ((then-run-with (file.exists? ref-file)) (fn is-ref ((((not is-ref) (fn _ (((((mpm-resolve-dependencies resolve) resolved) result) (cdr dependencies)) indef))) (fn _ ((then-run-with (file.read ref-file)) (fn ref ((((some? ((tree-map.get resolved) ref)) (fn _ (((((mpm-resolve-dependencies resolve) resolved) result) (cdr dependencies)) true))) (fn _ ((then-run-with (((parse-file (mpm-get-src ref)) ()) true)) (fn exprs ((then-run-with ((resolve (((tree-map.put resolved) ref) true)) ((generate-exprs' exprs) result))) (fn pair (((((mpm-resolve-dependencies resolve) (first pair)) (second pair)) (cdr dependencies)) true))))))) ()))))) ()))))))) ())))))))
(def mpm-resolve-generating (fn resolve (fn resolved (fn generating' ((then-run-with (((((mpm-resolve-dependencies resolve) resolved) generating') (generating.dependencies generating')) false)) (fn pair ((resolve (first pair)) (second pair))))))))
(def mpm-resolve-generated (fn resolve (fn resolved (fn generated' ((with (global-env.unresolved (generated.global-env generated'))) (fn unresolved ((((nil? unresolved) (fn _ (impure ((pair resolved) generated')))) (fn _ ((then-run-with (((((mpm-resolve-dependencies resolve) resolved) generated') unresolved) false)) (fn pair ((resolve (first pair)) (second pair)))))) ())))))))
(def mpm-resolve-generate-result' (fn resolved (fn result ((((generate-result.match result) (fn degenerate' (impure ((pair resolved) degenerate')))) ((mpm-resolve-generating mpm-resolve-generate-result') resolved)) ((mpm-resolve-generated mpm-resolve-generate-result') resolved)))))
(def mpm-resolve-generate-result (fn result (((swap run-with) second) ((mpm-resolve-generate-result' (empty-tree-map compare-symbol)) result))))
(def generate (fn in ((then-run-with (((parse-file in) ()) true)) (fn exprs (mpm-resolve-generate-result ((generate-exprs exprs) default-global-env))))))
(def desugar-file (fn in (fn out ((then-run-with (generate in)) (fn result ((with (desugar-declarations (generated.declarations result))) (fn desugared ((file.write out) desugared))))))))
(def compile (fn in (fn out ((then-run-with (generate in)) (fn result ((((generate-result.match result) (fn degenerate' (error (car (degenerate.errors degenerate'))))) (fn generating' (error ((flat-map (generating.dependencies generating')) ((swap append) space))))) (fn generated' ((write-result generated') out))))))))
(def mpm-put (fn in ((then-run-with (generate in)) (fn result ((then-run (mpm-put-refs (generated.declarations result))) (mpm-put-srcs in))))))
(def repl (fn global-env (fn heap (fn index (fn resolved ((then-run-with ((then-run ((ostream.write stdout) (car (symbol >)))) (istream.readln stdin))) (fn line (((((symbol.= ((filter line) ((compose not) whitespace?))) ()) (fn _ (impure ()))) (fn _ ((with ((char.= (car line)) (car (symbol !)))) (fn !? ((with ((repl-parse ((concat (symbol ""(def it "")) ((append (((!? (fn _ (cdr line))) (fn _ line)) ())) close-parentheses))) index)) (fn expr ((then-run-with ((mpm-resolve-generate-result' resolved) (((generate-expr expr) default-local-env) global-env))) (fn pair ((with ((repl-interpret-declarations (second pair)) heap)) (fn new-heap ((with ((repl-interpret-operation (second pair)) new-heap)) (fn value (((((!? (fn _ then-run-with)) (fn _ with)) ()) value) (fn v ((((((const repl) (debug v)) ((global-env.with-globals ((tree-map.remove (global-env.globals (generated.global-env (second pair)))) (symbol it))) (generated.global-env (second pair)))) new-heap) (nat.inc index)) (first pair)))))))))))))))) ()))))))))
(def empty-repl ((((repl default-global-env) empty-heap) nat.1) (empty-tree-map compare-symbol)))
(def run-repl (fn in ((then-run-with (generate in)) (fn result ((((repl (generated.global-env result)) ((interpret-declarations (generated.declarations result)) empty-heap)) nat.1) (empty-tree-map compare-symbol))))))
(def """" (fn args ((((nil? args) (fn _ empty-repl)) (fn _ ((with ((file.child file.local-file) (car args))) (fn in ((((nil? (cdr args)) (fn _ (run-repl in))) (fn _ ((with ((file.child file.local-file) (cadr args))) (fn out ((((nil? (cddr args)) (fn _ ((compile in) out))) (fn _ (error (symbol ""Usage: mc <in> <out>"")))) ()))))) ()))))) ())))
(def success (left ()))
(def failure (fn messages (right messages)))
(def fail (fn message (failure ((cons message) ()))))
(def combine-tests (fn tests (fn _ (((fold tests) success) (fn state (fn test (((test ()) (const state)) (fn failure1 ((state (fn _ (failure failure1))) (fn failure2 (failure ((concat failure1) failure2))))))))))))
(def run-test (fn test (((test ()) (fn success ((ostream.writeln stdout) (symbol ""Tests successful"")))) (fn failure (((fold failure) (impure ())) (fn process (fn message ((then-run process) ((ostream.writeln stderr) message)))))))))
(def test-condition (fn condition (fn message (((condition (fn _ success)) (fn _ (fail message))) ()))))
(def assert (fn expr (expr.list ((cons (expr.symbol (symbol delay))) ((cons (expr.list ((cons (expr.symbol (symbol test-condition))) ((cons (car expr)) ((cons (expr.list ((cons (expr.symbol (symbol symbol))) ((cons (expr.symbol (symbol ""Assertion failed""))) ())))) ()))))) ())))))
(def test-compare (fn compare (fn min (fn max (combine-tests ((cons (fn _ ((test-condition (compare<? ((compare min) max))) (symbol ""Assertion failed"")))) ((cons (fn _ ((test-condition (compare>? ((compare max) min))) (symbol ""Assertion failed"")))) ((cons (fn _ ((test-condition (compare=? ((compare min) min))) (symbol ""Assertion failed"")))) ((cons (fn _ ((test-condition (compare=? ((compare max) max))) (symbol ""Assertion failed"")))) ())))))))))
(def assert-not (fn expr (expr.list ((cons (expr.symbol (symbol assert))) ((cons (expr.list ((cons (expr.symbol (symbol not))) ((cons (car expr)) ())))) ())))))
(def char:test (combine-tests ((cons (fn _ ((test-condition (not ((char.= linefeed) carriage-return))) (symbol ""Assertion failed"")))) ((cons (fn _ ((test-condition (newline? linefeed)) (symbol ""Assertion failed"")))) ((cons (fn _ ((test-condition (newline? carriage-return)) (symbol ""Assertion failed"")))) ((cons (fn _ ((test-condition (whitespace? space)) (symbol ""Assertion failed"")))) ((cons (fn _ ((test-condition (whitespace? tab)) (symbol ""Assertion failed"")))) ((cons (((test-compare compare-char) linefeed) carriage-return)) ()))))))))
(def bool:test (combine-tests ((cons (fn _ ((test-condition true) (symbol ""Assertion failed"")))) ((cons (fn _ ((test-condition (not false)) (symbol ""Assertion failed"")))) ((cons (fn _ ((test-condition (not false)) (symbol ""Assertion failed"")))) ((cons (fn _ ((test-condition (not (not true))) (symbol ""Assertion failed"")))) ((cons (fn _ ((test-condition ((and true) (fn _ true))) (symbol ""Assertion failed"")))) ((cons (fn _ ((test-condition (not ((and true) (fn _ false)))) (symbol ""Assertion failed"")))) ((cons (fn _ ((test-condition (not ((and false) (fn _ true)))) (symbol ""Assertion failed"")))) ((cons (fn _ ((test-condition (not ((and false) (fn _ false)))) (symbol ""Assertion failed"")))) ((cons (fn _ ((test-condition ((or true) (fn _ true))) (symbol ""Assertion failed"")))) ((cons (fn _ ((test-condition ((or true) (fn _ false))) (symbol ""Assertion failed"")))) ((cons (fn _ ((test-condition ((or false) (fn _ true))) (symbol ""Assertion failed"")))) ((cons (fn _ ((test-condition (not ((or false) (fn _ false)))) (symbol ""Assertion failed"")))) ()))))))))))))))
(def mc:test (combine-tests ((cons bool:test) ((cons char:test) ()))))
(def either:test (combine-tests ((cons (fn _ ((test-condition (left? (left ()))) (symbol ""Assertion failed"")))) ((cons (fn _ ((test-condition (right? (right ()))) (symbol ""Assertion failed"")))) ((cons (fn _ ((test-condition (not (left? (right ())))) (symbol ""Assertion failed"")))) ((cons (fn _ ((test-condition (not (right? (left ())))) (symbol ""Assertion failed"")))) ()))))))
