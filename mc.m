(def desugar-nil-operation (fn desugar-operation (fn operation (symbol "()"))))
(def mangle-fn-name ())
(def interpret-nil-operation (fn interpret-operation' (fn operation (fn stack (fn heap ())))))
(def write-program ())
(def mpm-root mpm-root)
(def debug ())
(def file.exists? ())
(def id (fn x x))
(def normalize id)
(def unnormalize id)
(def const (fn x (fn "" x)))
(def desugar-fn-declaration (const (symbol "")))
(def compose (fn f (fn g (fn x (f (g x))))))
(def swap (fn f (fn x (fn y ((f y) x)))))
(def apply (fn f (fn x (f x))))
(def with (swap apply))
(def impure (fn x (fn f (f x))))
(def then-run-with (fn p (fn f (p f))))
(def then-run (fn p1 (fn p2 ((then-run-with p1) (const p2)))))
(def run-with (fn p (fn f ((then-run-with p) ((compose impure) f)))))
(def symbol->list id)
(def unnull (fn either ((either id) id)))
(def pair (fn first (fn second (fn x ((x first) second)))))
(def true (id const))
(def first (fn pair (pair true)))
(def type-name first)
(def false (const id))
(def second (fn pair (pair false)))
(def and (fn x (fn y (((x (fn "" (y ()))) (fn "" false)) ()))))
(def or (fn x (fn y (((x (fn "" true)) (fn "" (y ()))) ()))))
(def not (fn x (((x (fn "" false)) (fn "" true)) ())))
(def char->nat id)
(def left (fn value (fn first (fn "" (first value)))))
(def null (left ()))
(def empty-heap (const null))
(def right (fn value (fn "" (fn second (second value)))))
(def some right)
(def left? (fn either ((either (const true)) (const false))))
(def null? left?)
(def right? (fn either ((either (const false)) (const true))))
(def some? right?)
(def heap.+ (fn heap1 (fn heap2 (fn name ((with (heap1 name)) (fn value ((((some? value) (fn "" value)) (fn "" (heap2 name))) ())))))))
(def ostream.write (fn ostream (fn char (ostream char))))
(def stdout ())
(def stdin ())
(def nil ())
(def cons pair)
(def car first)
(def open-parentheses (car (symbol "(")))
(def close-parentheses (car (symbol ")")))
(def semicolon (car (symbol ";")))
(def dot (car (symbol .)))
(def quote (car (symbol "\"")))
(def slash (car (symbol /)))
(def backslash (car (symbol "\\")))
(def space (car (symbol " ")))
(def tab (car (symbol "	")))
(def linefeed (car (symbol "
")))
(def carriage-return (car (symbol "")))
(def letter-t (car (symbol t)))
(def letter-n (car (symbol n)))
(def letter-r (car (symbol r)))
(def cdr second)
(def cddr ((compose cdr) cdr))
(def cdddr ((compose cdr) cddr))
(def cadr ((compose car) cdr))
(def caddr ((compose car) cddr))
(def cadddr ((compose car) cdddr))
(def nil? (fn list ((list (const (const (const false)))) true)))
(def ostream.writeln (fn ostream (fn line ((((nil? line) (fn "" ((ostream.write ostream) linefeed))) (fn "" ((then-run ((ostream.write ostream) (car line))) ((ostream.writeln ostream) (cdr line))))) ()))))
(def list1 (fn a ((cons a) ())))
(def list2 (fn a (fn b ((cons a) (list1 b)))))
(def list3 (fn a (fn b (fn c ((cons a) ((list2 b) c))))))
(def list4 (fn a (fn b (fn c (fn d ((cons a) (((list3 b) c) d)))))))
(def list5 (fn a (fn b (fn c (fn d (fn e ((cons a) ((((list4 b) c) d) e))))))))
(def list6 (fn a (fn b (fn c (fn d (fn e (fn f ((cons a) (((((list5 b) c) d) e) f)))))))))
(def append (fn list (fn elem ((((nil? list) (fn "" (list1 elem))) (fn "" ((cons (car list)) ((append (cdr list)) elem)))) ()))))
(def concat (fn list1 (fn list2 ((((nil? list1) (fn "" list2)) (fn "" ((cons (car list1)) ((concat (cdr list1)) list2)))) ()))))
(def symbol.+ concat)
(def object (fn type ((pair type) (fn name ((concat (symbol->list (symbol "Could not find field "))) ((concat (symbol->list name)) ((concat (symbol->list (symbol " for "))) (symbol->list type))))))))
(def nil-operation (object (symbol nil-operation)))
(def tree-map-node-nil (object (symbol tree-map-node-nil)))
(def map (fn list (fn f ((((nil? list) (fn "" ())) (fn "" ((cons (f (car list))) ((map (cdr list)) f)))) ()))))
(def flat-map (fn list (fn f ((((nil? list) (fn "" ())) (fn "" ((concat (f (car list))) ((flat-map (cdr list)) f)))) ()))))
(def filter (fn list (fn f ((((nil? list) (fn "" ())) (fn "" ((((f (car list)) (fn "" ((cons (car list)) ((filter (cdr list)) f)))) (fn "" ((filter (cdr list)) f))) ()))) ()))))
(def fold (fn list (fn acc (fn f ((((nil? list) (fn "" acc)) (fn "" (((fold (cdr list)) ((f acc) (car list))) f))) ())))))
(def reverse' (fn list (fn acc ((((nil? list) (fn "" acc)) (fn "" ((reverse' (cdr list)) ((cons (car list)) acc)))) ()))))
(def reverse (fn list ((reverse' list) ())))
(def list.= (fn f (fn list1 (fn list2 ((((nil? list1) (fn "" (nil? list2))) (fn "" ((((nil? list2) (fn "" false)) (fn "" ((and ((f (car list1)) (car list2))) (fn "" (((list.= f) (cdr list1)) (cdr list2)))))) ()))) ())))))
(def nat.0 (left id))
(def nat.1 (right nat.0))
(def nat.0? left?)
(def nat.inc right)
(def nat.dec (fn nat ((nat left) id)))
(def get (fn list (fn n ((((nat.0? n) (fn "" (car list))) (fn "" ((get (cdr list)) (nat.dec n)))) ()))))
(def nat.+ (fn x (fn y ((((nat.0? y) (fn "" x)) (fn "" ((nat.+ (nat.inc x)) (nat.dec y)))) ()))))
(def nat.- (fn x (fn y ((((nat.0? y) (fn "" x)) (fn "" ((nat.- (nat.dec x)) (nat.dec y)))) ()))))
(def nat.< (fn x (fn y ((((nat.0? x) (fn "" (not (nat.0? y)))) (fn "" ((((nat.0? y) (fn "" false)) (fn "" ((nat.< (nat.dec x)) (nat.dec y)))) ()))) ()))))
(def nat.> (swap nat.<))
(def nat.= (fn x (fn y ((((nat.0? x) (fn "" (nat.0? y))) (fn "" ((((nat.0? y) (fn "" false)) (fn "" ((nat.= (nat.dec x)) (nat.dec y)))) ()))) ()))))
(def char.= nat.=)
(def escape (fn char (((((char.= char) letter-t) (fn "" tab)) (fn "" (((((char.= char) letter-n) (fn "" linefeed)) (fn "" (((((char.= char) letter-r) (fn "" carriage-return)) (fn "" char)) ()))) ()))) ())))
(def newline? (fn char ((or ((char.= char) linefeed)) (fn "" ((char.= char) carriage-return)))))
(def parse-comment (fn parse-expr (fn input (fn path (fn position (((((or (nil? input)) (fn "" (newline? (car input)))) (fn "" (((parse-expr input) path) position))) (fn "" ((((parse-comment parse-expr) (cdr input)) path) position))) ()))))))
(def whitespace? (fn char ((or ((char.= char) space)) (fn "" ((or ((char.= char) tab)) (fn "" (newline? char)))))))
(def separator? (fn char ((or (whitespace? char)) (fn "" ((or ((char.= char) open-parentheses)) (fn "" ((or ((char.= char) close-parentheses)) (fn "" ((or ((char.= char) semicolon)) (fn "" ((char.= char) quote)))))))))))
(def desugar-should-quote? (fn name ((((nil? name) (fn "" false)) (fn "" ((with (car name)) (fn char (((((char.= char) quote) (fn "" true)) (fn "" (((((char.= char) backslash) (fn "" true)) (fn "" (((((char.= char) open-parentheses) (fn "" true)) (fn "" (((((char.= char) close-parentheses) (fn "" true)) (fn "" (((((char.= char) semicolon) (fn "" true)) (fn "" ((((whitespace? char) (fn "" true)) (fn "" (desugar-should-quote? (cdr name)))) ()))) ()))) ()))) ()))) ()))) ()))))) ())))
(def desugar-quote (fn name (((((or (desugar-should-quote? name)) (fn "" (nil? name))) (fn "" ((with ((flat-map name) (fn char (((((char.= char) quote) (fn "" (symbol "\\\""))) (fn "" (((((char.= char) backslash) (fn "" (symbol "\\\\"))) (fn "" (list1 char))) ()))) ())))) (fn escaped ((cons quote) ((append escaped) quote)))))) (fn "" name)) ())))
(def symbol.= (list.= char.=))
(def is? (fn type (fn data ((symbol.= type) (type-name data)))))
(def def-declaration? (is? (symbol def-declaration)))
(def fn-declaration? (is? (symbol fn-declaration)))
(def identifier-expr? (is? (symbol identifier-expr)))
(def list-expr? (is? (symbol list-expr)))
(def generating? (is? (symbol generating)))
(def generated? (is? (symbol generated)))
(def degenerate? (is? (symbol degenerate)))
(def local-variable? (is? (symbol local-variable)))
(def global-variable? (is? (symbol global-variable)))
(def tree-map-node-nil? (is? (symbol tree-map-node-nil)))
(def derive (fn data (fn name (fn value ((pair (first data)) (fn field (((((symbol.= field) name) (fn "" value)) (fn "" ((second data) field))) ())))))))
(def data (fn type (fn fields (((fold fields) (object type)) (fn data (fn field (((derive data) (first field)) (second field))))))))
(def new-data' (fn type (fn names (fn fields ((((nil? names) (fn "" ((data type) fields))) (fn "" (fn value (((new-data' type) (cdr names)) ((cons ((pair (car names)) value)) fields))))) ())))))
(def new-data (fn type (fn names (((new-data' type) names) ()))))
(def def-declaration ((new-data (symbol def-declaration)) (((list3 (symbol name)) (symbol path)) (symbol value))))
(def fn-declaration ((new-data (symbol fn-declaration)) ((((list4 (symbol name)) (symbol path)) (symbol closures)) (symbol value))))
(def local-env ((new-data (symbol local-env)) ((list2 (symbol locals)) (symbol def))))
(def global-env ((new-data (symbol global-env)) ((((list4 (symbol globals)) (symbol heap)) (symbol dependents)) (symbol index))))
(def identifier-expr ((new-data (symbol identifier-expr)) ((((list4 (symbol name)) (symbol path)) (symbol start)) (symbol end))))
(def list-expr ((new-data (symbol list-expr)) ((((list4 (symbol exprs)) (symbol path)) (symbol start)) (symbol end))))
(def generating ((new-data (symbol generating)) (((list3 (symbol dependencies)) (symbol global-env)) (symbol continue))))
(def generated ((new-data (symbol generated)) (((list3 (symbol operation)) (symbol declarations)) (symbol global-env))))
(def generate-nil (fn local-env (fn global-env (((generated nil-operation) ()) global-env))))
(def degenerate ((new-data (symbol degenerate)) ((list2 (symbol errors)) (symbol global-env))))
(def local-variable-operation ((new-data (symbol local-variable-operation)) ((list2 (symbol name)) (symbol index))))
(def global-variable-operation ((new-data (symbol global-variable-operation)) ((list2 (symbol name)) (symbol path))))
(def if-operation ((new-data (symbol if-operation)) (((list3 (symbol cond)) (symbol true)) (symbol false))))
(def def-operation ((new-data (symbol def-operation)) (((list3 (symbol name)) (symbol path)) (symbol value))))
(def fn-operation ((new-data (symbol fn-operation)) (((((list5 (symbol path)) (symbol name)) (symbol arg)) (symbol value)) (symbol closures))))
(def symbol-operation ((new-data (symbol symbol-operation)) (list1 (symbol name))))
(def generate-symbol-expr (fn name (fn local-env (fn global-env (((generated (symbol-operation name)) ()) global-env)))))
(def apply-operation ((new-data (symbol apply-operation)) ((list2 (symbol fn)) (symbol arg))))
(def line-number-operation ((new-data (symbol line-number-operation)) ((list2 (symbol operation)) (symbol line))))
(def position ((new-data (symbol position)) ((list2 (symbol line)) (symbol char))))
(def start-position ((position nat.1) nat.1))
(def list->expr (fn either ((either (fn name ((((identifier-expr name) ()) start-position) start-position))) (fn list ((((list-expr ((map list) list->expr)) ()) start-position) start-position)))))
(def parse-result ((new-data (symbol parse-result)) ((list2 (symbol rest)) (symbol expr))))
(def local-variable ((new-data (symbol local-variable)) ((list2 (symbol name)) (symbol index))))
(def global-variable ((new-data (symbol global-variable)) (((list3 (symbol name)) (symbol path)) (symbol macro?))))
(def tree-map-node ((new-data (symbol tree-map-node)) ((((list4 (symbol left)) (symbol right)) (symbol key)) (symbol value))))
(def tree-map ((new-data (symbol tree-map)) ((list2 (symbol node)) (symbol compare))))
(def empty-tree-map (fn compare ((tree-map tree-map-node-nil) compare)))
(def istream.read (fn istream istream))
(def istream.readln (fn istream ((then-run-with istream) (fn char ((((newline? char) (fn "" (impure ()))) (fn "" ((run-with (istream.readln istream)) (fn line ((cons char) line))))) ())))))
(def compare= (object (symbol compare=)))
(def compare< (object (symbol compare<)))
(def compare> (object (symbol compare>)))
(def compare=? (is? (symbol compare=)))
(def compare<? (is? (symbol compare<)))
(def compare>? (is? (symbol compare>)))
(def fold-compare (fn compare (fn < (fn > (fn = ((((compare<? compare) (fn "" (< compare))) (fn "" ((((compare>? compare) (fn "" (> compare))) (fn "" (= compare))) ()))) ()))))))
(def compare-list (fn compare (fn list1 (fn list2 (((((and (nil? list1)) (fn "" (nil? list2))) (fn "" compare=)) (fn "" ((((nil? list1) (fn "" compare<)) (fn "" ((((nil? list2) (fn "" compare>)) (fn "" ((fn compare-result ((((compare=? compare-result) (fn "" (((compare-list compare) (cdr list1)) (cdr list2)))) (fn "" compare-result)) ())) ((compare (car list1)) (car list2))))) ()))) ()))) ())))))
(def compare-nat (fn nat1 (fn nat2 (((((nat.> nat1) nat2) (fn "" compare>)) (fn "" (((((nat.< nat1) nat2) (fn "" compare<)) (fn "" compare=)) ()))) ()))))
(def compare-char (fn char1 (fn char2 ((compare-nat (char->nat char1)) (char->nat char2)))))
(def compare-symbol (compare-list compare-char))
(def default-local-env ((local-env (empty-tree-map compare-symbol)) ()))
(def default-global-env ((((global-env (empty-tree-map compare-symbol)) empty-heap) (empty-tree-map compare-symbol)) nat.0))
(def file.local-file ())
(def file.name ())
(def file.name-without-extension ())
(def file.child ())
(def mpm-ref-root ((file.child mpm-root) (symbol ref)))
(def mpm-src-root ((file.child mpm-root) (symbol src)))
(def mpm-get-ref (fn name ((file.child mpm-ref-root) (normalize name))))
(def mpm-get-src (fn ref ((file.child mpm-src-root) ((concat ref) (symbol .m)))))
(def file.read ())
(def file.write ())
(def file.directory? ())
(def file.child-files ())
(def file.copy ())
(def mpm-put-srcs (fn in ((file.copy in) mpm-src-root)))
(def error ())
(def heap.get (fn heap (fn name ((with (heap name)) (fn value ((((null? value) (fn "" (error ((concat (symbol->list (symbol "Could not find "))) name)))) (fn "" ((unnull value) heap))) ()))))))
(def generate-result.match (fn result (fn degenerate' (fn generating' (fn generated' ((((generated? result) (fn "" (generated' result))) (fn "" ((((generating? result) (fn "" (generating' result))) (fn "" ((((degenerate? result) (fn "" (degenerate' result))) (fn "" (error (symbol ...)))) ()))) ()))) ()))))))
(def as (fn type (fn data (((((is? type) data) (fn "" data)) (fn "" (error ((concat (symbol->list (symbol "Could not cast "))) ((concat (symbol->list (type-name data))) ((concat (symbol->list (symbol " to "))) (symbol->list type))))))) ()))))
(def field (fn type (fn name (fn data ((second ((as type) data)) name)))))
(def def-declaration.name ((field (symbol def-declaration)) (symbol name)))
(def def-declaration.path ((field (symbol def-declaration)) (symbol path)))
(def mpm-put-refs (fn declarations ((with ((filter declarations) def-declaration?)) (fn def-declarations (((fold def-declarations) (impure ())) (fn process (fn declaration ((then-run process) ((file.write ((file.child mpm-ref-root) (normalize (def-declaration.name declaration)))) (def-declaration.path declaration))))))))))
(def def-declaration.value ((field (symbol def-declaration)) (symbol value)))
(def fn-declaration.name ((field (symbol fn-declaration)) (symbol name)))
(def declaration.name (fn declaration ((((def-declaration? declaration) (fn "" (def-declaration.name declaration))) (fn "" (fn-declaration.name declaration))) ())))
(def fn-declaration.path ((field (symbol fn-declaration)) (symbol path)))
(def fn-declaration.closures ((field (symbol fn-declaration)) (symbol closures)))
(def fn-declaration.value ((field (symbol fn-declaration)) (symbol value)))
(def declaration.value (fn declaration ((((def-declaration? declaration) (fn "" (def-declaration.value declaration))) (fn "" (fn-declaration.value declaration))) ())))
(def local-env.locals ((field (symbol local-env)) (symbol locals)))
(def local-env.with-def (fn def (fn e ((local-env (local-env.locals e)) def))))
(def local-env.def ((field (symbol local-env)) (symbol def)))
(def local-env.with-locals (fn locals (fn e ((local-env locals) (local-env.def e)))))
(def global-env.globals ((field (symbol global-env)) (symbol globals)))
(def global-env.heap ((field (symbol global-env)) (symbol heap)))
(def global-env.dependents ((field (symbol global-env)) (symbol dependents)))
(def global-env.with-index (fn index (fn e ((((global-env (global-env.globals e)) (global-env.heap e)) (global-env.dependents e)) index))))
(def global-env.index ((field (symbol global-env)) (symbol index)))
(def global-env.with-dependents (fn dependents (fn e ((((global-env (global-env.globals e)) (global-env.heap e)) dependents) (global-env.index e)))))
(def global-env.with-heap (fn heap (fn e ((((global-env (global-env.globals e)) heap) (global-env.dependents e)) (global-env.index e)))))
(def global-env.with-globals (fn globals (fn e ((((global-env globals) (global-env.heap e)) (global-env.dependents e)) (global-env.index e)))))
(def identifier-expr.name ((field (symbol identifier-expr)) (symbol name)))
(def identifier-expr.path ((field (symbol identifier-expr)) (symbol path)))
(def identifier-expr.start ((field (symbol identifier-expr)) (symbol start)))
(def identifier-expr.end ((field (symbol identifier-expr)) (symbol end)))
(def list-expr.exprs ((field (symbol list-expr)) (symbol exprs)))
(def expr->list (fn expr ((((identifier-expr? expr) (fn "" (left (identifier-expr.name expr)))) (fn "" (right ((map (list-expr.exprs expr)) expr->list)))) ())))
(def generate-macro-apply-expr (fn generate-expr (fn expr (fn name (fn args (fn local-env (fn global-env ((with ((heap.get (global-env.heap global-env)) name)) (fn function (((generate-expr ((((list-expr ((map (function ((map args) expr->list))) list->expr)) (identifier-expr.path expr)) (identifier-expr.start expr)) (identifier-expr.end expr))) local-env) global-env))))))))))
(def list-expr.path ((field (symbol list-expr)) (symbol path)))
(def expr.path (fn expr ((((list-expr? expr) (fn "" (list-expr.path expr))) (fn "" (identifier-expr.path expr))) ())))
(def list-expr.start ((field (symbol list-expr)) (symbol start)))
(def expr.start (fn expr ((((list-expr? expr) (fn "" (list-expr.start expr))) (fn "" (identifier-expr.start expr))) ())))
(def list-expr.end ((field (symbol list-expr)) (symbol end)))
(def expr.end (fn expr ((((list-expr? expr) (fn "" (list-expr.end expr))) (fn "" (identifier-expr.end expr))) ())))
(def generate-if-expr (fn generate-expr (fn cond-expr (fn true-expr (fn false-expr (fn local-env (fn global-env (((generate-expr ((((list-expr ((list2 ((((list-expr (((list3 cond-expr) ((((list-expr (((list3 ((((identifier-expr (symbol fn)) (expr.path true-expr)) (expr.start true-expr)) (expr.end true-expr))) ((((identifier-expr (symbol "")) (expr.path true-expr)) (expr.start true-expr)) (expr.end true-expr))) true-expr)) (expr.path true-expr)) (expr.start true-expr)) (expr.end true-expr))) ((((list-expr (((list3 ((((identifier-expr (symbol fn)) (expr.path false-expr)) (expr.start false-expr)) (expr.end false-expr))) ((((identifier-expr (symbol "")) (expr.path false-expr)) (expr.start false-expr)) (expr.end false-expr))) false-expr)) (expr.path false-expr)) (expr.start false-expr)) (expr.end false-expr)))) (expr.path cond-expr)) (expr.start cond-expr)) (expr.end cond-expr))) ((((list-expr ()) (expr.path cond-expr)) (expr.start cond-expr)) (expr.start cond-expr)))) (expr.path cond-expr)) (expr.start cond-expr)) (expr.end cond-expr))) local-env) global-env))))))))
(def generating.dependencies ((field (symbol generating)) (symbol dependencies)))
(def generating.global-env ((field (symbol generating)) (symbol global-env)))
(def generating.continue ((field (symbol generating)) (symbol continue)))
(def generated-resolve-generating (fn generated.combine (fn generated' (fn generating' (fn global-env (fn f (((generating (generating.dependencies generating')) global-env) (fn global-env ((((generated.combine generated') ((generating.continue generating') global-env)) global-env) f)))))))))
(def generated.operation ((field (symbol generated)) (symbol operation)))
(def generated.declarations ((field (symbol generated)) (symbol declarations)))
(def write-result (fn result (fn out (((write-program out) (generated.operation result)) (generated.declarations result)))))
(def generated.global-env ((field (symbol generated)) (symbol global-env)))
(def degenerate.errors ((field (symbol degenerate)) (symbol errors)))
(def degenerate.with-global-env (fn env (fn degenerate' ((degenerate (degenerate.errors degenerate')) env))))
(def generated.combine (fn generated1 (fn result (fn global-env (fn f ((((generate-result.match result) (fn degenerate2 ((degenerate.with-global-env global-env) degenerate2))) (fn generating2 (((((generated-resolve-generating generated.combine) generated1) generating2) global-env) f))) (fn generated2 (((generated ((f (generated.operation generated1)) (generated.operation generated2))) ((concat (generated.declarations generated1)) (generated.declarations generated2))) global-env))))))))
(def generating.combine (fn generating1 (fn result (fn global-env (fn f ((((generate-result.match result) (fn degenerate2 ((degenerate.with-global-env global-env) degenerate2))) (fn generating2 (((generating ((concat (generating.dependencies generating1)) (generating.dependencies generating2))) global-env) (fn global-env ((((generating.combine generating1) generating2) global-env) f))))) (fn generated2 (((((generated-resolve-generating generated.combine) generated2) generating1) global-env) (swap f)))))))))
(def degenerate.combine (fn degenerate1 (fn result (fn global-env (fn f ((((generate-result.match result) (fn degenerate2 ((degenerate ((concat (degenerate.errors degenerate1)) (degenerate.errors degenerate2))) global-env))) (fn generating2 ((degenerate.with-global-env global-env) degenerate1))) (fn generated2 ((degenerate.with-global-env global-env) degenerate1))))))))
(def generate-result.combine (fn result1 (fn result2 (fn global-env (fn f ((((generate-result.match result1) (fn degenerate1 ((((degenerate.combine degenerate1) result2) global-env) f))) (fn generating1 ((((generating.combine generating1) result2) global-env) f))) (fn generated1 ((((generated.combine generated1) result2) global-env) f))))))))
(def degenerate.global-env ((field (symbol degenerate)) (symbol global-env)))
(def generate-result.global-env (fn result ((((generate-result.match result) degenerate.global-env) generating.global-env) generated.global-env)))
(def generate-apply-expr' (fn fn-result (fn arg-result ((((generate-result.combine fn-result) arg-result) (generate-result.global-env arg-result)) apply-operation))))
(def generate-apply-expr (fn generate-expr (fn fn (fn args (fn local-env (fn global-env ((with (((generate-expr fn) local-env) global-env)) (fn fn-result (((fold args) fn-result) (fn fn-result (fn arg ((with (((generate-expr arg) local-env) (generate-result.global-env fn-result))) (fn arg-result ((generate-apply-expr' fn-result) arg-result))))))))))))))
(def local-variable-operation.name ((field (symbol local-variable-operation)) (symbol name)))
(def desugar-local-variable-operation (fn desugar-operation (fn operation (desugar-quote (local-variable-operation.name operation)))))
(def local-variable-operation.index ((field (symbol local-variable-operation)) (symbol index)))
(def interpret-local-variable-operation (fn interpret-operation' (fn operation (fn stack (fn heap ((get stack) (local-variable-operation.index operation)))))))
(def global-variable-operation.name ((field (symbol global-variable-operation)) (symbol name)))
(def desugar-global-variable-operation (fn desugar-operation (fn operation (desugar-quote (global-variable-operation.name operation)))))
(def interpret-global-variable-operation (fn interpret-operation' (fn operation (fn stack (fn heap ((heap.get heap) (global-variable-operation.name operation)))))))
(def global-variable-operation.path ((field (symbol global-variable-operation)) (symbol path)))
(def if-operation.cond ((field (symbol if-operation)) (symbol cond)))
(def if-operation.true ((field (symbol if-operation)) (symbol true)))
(def if-operation.false ((field (symbol if-operation)) (symbol false)))
(def interpret-if-operation (fn interpret-operation' (fn operation (fn stack (fn heap ((((((interpret-operation' (if-operation.cond operation)) stack) heap) (fn "" (((interpret-operation' (if-operation.true operation)) stack) heap))) (fn "" (((interpret-operation' (if-operation.false operation)) stack) heap))) ()))))))
(def def-operation.name ((field (symbol def-operation)) (symbol name)))
(def desugar-def-operation (fn desugar-operation (fn operation (def-operation.name operation))))
(def interpret-def-operation (fn interpret-operation' (fn operation (fn stack (fn heap ((heap.get heap) (def-operation.name operation)))))))
(def def-operation.path ((field (symbol def-operation)) (symbol path)))
(def def-operation.value ((field (symbol def-operation)) (symbol value)))
(def fn-operation.path ((field (symbol fn-operation)) (symbol path)))
(def fn-operation.name ((field (symbol fn-operation)) (symbol name)))
(def fn-operation.arg ((field (symbol fn-operation)) (symbol arg)))
(def fn-operation.value ((field (symbol fn-operation)) (symbol value)))
(def desugar-fn-operation (fn desugar-operation (fn operation ((concat (symbol "(fn ")) ((concat (desugar-quote (fn-operation.arg operation))) ((concat (symbol " ")) ((concat (desugar-operation (fn-operation.value operation))) (symbol ")"))))))))
(def fn-operation.closures ((field (symbol fn-operation)) (symbol closures)))
(def interpret-fn-operation (fn interpret-operation' (fn operation (fn stack (fn heap (fn arg ((((heap.get heap) (fn-operation.name operation)) (concat ((map (fn-operation.closures operation)) (fn closure (((interpret-operation' closure) stack) heap))))) ((cons arg) stack))))))))
(def symbol-operation.name ((field (symbol symbol-operation)) (symbol name)))
(def interpret-symbol-operation (fn interpret-operation' (fn operation (fn stack (fn heap (symbol-operation.name operation))))))
(def desugar-symbol-operation (fn desugar-operation (fn operation ((concat (symbol "(symbol ")) ((concat (desugar-quote (symbol-operation.name operation))) (symbol ")"))))))
(def apply-operation.fn ((field (symbol apply-operation)) (symbol fn)))
(def apply-operation.arg ((field (symbol apply-operation)) (symbol arg)))
(def interpret-apply-operation (fn interpret-operation' (fn operation (fn stack (fn heap ((((interpret-operation' (apply-operation.fn operation)) stack) heap) (((interpret-operation' (apply-operation.arg operation)) stack) heap)))))))
(def desugar-apply-operation (fn desugar-operation (fn operation ((concat (symbol "(")) ((concat (desugar-operation (apply-operation.fn operation))) ((concat (symbol " ")) ((concat (desugar-operation (apply-operation.arg operation))) (symbol ")"))))))))
(def line-number-operation.operation ((field (symbol line-number-operation)) (symbol operation)))
(def desugar-line-number-operation (fn desugar-operation (fn operation (desugar-operation (line-number-operation.operation operation)))))
(def desugar-operation (fn operation ((((fn type (((((symbol.= type) (symbol local-variable-operation)) (fn "" desugar-local-variable-operation)) (fn "" (((((symbol.= type) (symbol global-variable-operation)) (fn "" desugar-global-variable-operation)) (fn "" (((((symbol.= type) (symbol def-operation)) (fn "" desugar-def-operation)) (fn "" (((((symbol.= type) (symbol fn-operation)) (fn "" desugar-fn-operation)) (fn "" (((((symbol.= type) (symbol symbol-operation)) (fn "" desugar-symbol-operation)) (fn "" (((((symbol.= type) (symbol apply-operation)) (fn "" desugar-apply-operation)) (fn "" (((((symbol.= type) (symbol line-number-operation)) (fn "" desugar-line-number-operation)) (fn "" (((((symbol.= type) (symbol nil-operation)) (fn "" desugar-nil-operation)) (fn "" (error (symbol ...)))) ()))) ()))) ()))) ()))) ()))) ()))) ()))) ())) (type-name operation)) desugar-operation) operation)))
(def desugar-def-declaration (fn declaration ((concat (symbol "(def ")) ((concat (desugar-quote (def-declaration.name declaration))) ((concat (symbol " ")) ((concat (desugar-operation (def-declaration.value declaration))) ((append (symbol ")")) linefeed)))))))
(def desugar-declaration (fn declaration (((fn type (((((symbol.= type) (symbol def-declaration)) (fn "" desugar-def-declaration)) (fn "" (((((symbol.= type) (symbol fn-declaration)) (fn "" desugar-fn-declaration)) (fn "" (error (symbol ...)))) ()))) ())) (type-name declaration)) declaration)))
(def desugar-declarations (fn declarations ((flat-map declarations) desugar-declaration)))
(def interpret-line-number-operation (fn interpret-operation' (fn operation (interpret-operation' (line-number-operation.operation operation)))))
(def interpret-operation' (fn operation (fn stack (fn heap ((((((fn type (((((symbol.= type) (symbol local-variable-operation)) (fn "" interpret-local-variable-operation)) (fn "" (((((symbol.= type) (symbol global-variable-operation)) (fn "" interpret-global-variable-operation)) (fn "" (((((symbol.= type) (symbol if-operation)) (fn "" interpret-if-operation)) (fn "" (((((symbol.= type) (symbol def-operation)) (fn "" interpret-def-operation)) (fn "" (((((symbol.= type) (symbol fn-operation)) (fn "" interpret-fn-operation)) (fn "" (((((symbol.= type) (symbol symbol-operation)) (fn "" interpret-symbol-operation)) (fn "" (((((symbol.= type) (symbol apply-operation)) (fn "" interpret-apply-operation)) (fn "" (((((symbol.= type) (symbol line-number-operation)) (fn "" interpret-line-number-operation)) (fn "" (((((symbol.= type) (symbol nil-operation)) (fn "" interpret-nil-operation)) (fn "" (error (symbol ...)))) ()))) ()))) ()))) ()))) ()))) ()))) ()))) ()))) ())) (type-name operation)) interpret-operation') operation) stack) heap)))))
(def interpret-operation (fn operation (fn heap (((interpret-operation' operation) ()) heap))))
(def repl-interpret-operation (fn result (fn heap ((interpret-operation (generated.operation result)) heap))))
(def interpret-def-declaration (fn declaration (fn heap (fn name (((((symbol.= name) (def-declaration.name declaration)) (fn "" (some (fn heap' ((interpret-operation (def-declaration.value declaration)) heap'))))) (fn "" (heap name))) ())))))
(def interpret-fn-declaration (fn declaration (fn heap (fn name (((((symbol.= name) (fn-declaration.name declaration)) (fn "" (some (fn stack (fn heap' (((interpret-operation' (fn-declaration.value declaration)) stack) heap')))))) (fn "" (heap name))) ())))))
(def interpret-declaration (fn declaration (fn heap ((((fn type (((((symbol.= type) (symbol def-declaration)) (fn "" interpret-def-declaration)) (fn "" (((((symbol.= type) (symbol fn-declaration)) (fn "" interpret-fn-declaration)) (fn "" (error (symbol ...)))) ()))) ())) (type-name declaration)) declaration) heap))))
(def interpret-declarations (fn declarations (fn heap (((fold declarations) heap) (fn heap' (fn declaration ((interpret-declaration declaration) heap')))))))
(def repl-interpret-declarations (fn result (fn heap ((interpret-declarations (generated.declarations result)) heap))))
(def operation.fold (fn operation (fn acc (fn f ((f ((with (type-name operation)) (fn type (((((symbol.= type) (symbol local-variable-operation)) (fn "" acc)) (fn "" (((((symbol.= type) (symbol global-variable-operation)) (fn "" acc)) (fn "" (((((symbol.= type) (symbol if-operation)) (fn "" (((operation.fold (if-operation.false operation)) (((operation.fold (if-operation.true operation)) (((operation.fold (if-operation.cond operation)) acc) f)) f)) f))) (fn "" (((((symbol.= type) (symbol def-operation)) (fn "" (((operation.fold (def-operation.value operation)) acc) f))) (fn "" (((((symbol.= type) (symbol fn-operation)) (fn "" (((operation.fold (fn-operation.value operation)) acc) f))) (fn "" (((((symbol.= type) (symbol symbol-operation)) (fn "" acc)) (fn "" (((((symbol.= type) (symbol apply-operation)) (fn "" (((operation.fold (apply-operation.arg operation)) (((operation.fold (apply-operation.fn operation)) acc) f)) f))) (fn "" (((((symbol.= type) (symbol line-number-operation)) (fn "" (((operation.fold (line-number-operation.operation operation)) acc) f))) (fn "" (((((symbol.= type) (symbol nil-operation)) (fn "" acc)) (fn "" (error (symbol ...)))) ()))) ()))) ()))) ()))) ()))) ()))) ()))) ()))) ())))) operation)))))
(def line-number-operation.line ((field (symbol line-number-operation)) (symbol line)))
(def position.line ((field (symbol position)) (symbol line)))
(def next-line (fn p ((position ((nat.+ nat.1) (position.line p))) nat.1)))
(def position.char ((field (symbol position)) (symbol char)))
(def next-char (fn p ((position (position.line p)) ((nat.+ nat.1) (position.char p)))))
(def parse-identifier-expr (fn input (fn path (fn start (fn end (fn acc ((((separator? (car input)) (fn "" ((parse-result input) ((((identifier-expr (reverse acc)) path) start) end)))) (fn "" (((((parse-identifier-expr (cdr input)) path) start) (next-char end)) ((cons (car input)) acc)))) ())))))))
(def parse-identifier-literal-expr (fn input (fn path (fn start (fn end (fn acc ((with (car input)) (fn head (((((char.= head) quote) (fn "" ((parse-result (cdr input)) ((((identifier-expr (reverse acc)) path) start) end)))) (fn "" (((((char.= head) backslash) (fn "" (((((parse-identifier-literal-expr (cddr input)) path) start) (next-char (next-char end))) ((cons (escape (cadr input))) acc)))) (fn "" ((((newline? head) (fn "" (((((parse-identifier-literal-expr (cdr input)) path) start) (next-line end)) ((cons head) acc)))) (fn "" (((((parse-identifier-literal-expr (cdr input)) path) start) (next-char end)) ((cons head) acc)))) ()))) ()))) ())))))))))
(def parse-result.rest ((field (symbol parse-result)) (symbol rest)))
(def parse-result.expr ((field (symbol parse-result)) (symbol expr)))
(def parse-list-expr (fn parse-expr (fn input (fn path (fn start (fn end (fn acc (((((char.= (car input)) close-parentheses) (fn "" ((parse-result (cdr input)) ((((list-expr (reverse acc)) path) start) end)))) (fn "" ((with (((parse-expr input) path) end)) (fn result ((((((parse-list-expr parse-expr) (parse-result.rest result)) path) start) (expr.end (parse-result.expr result))) ((cons (parse-result.expr result)) acc)))))) ()))))))))
(def parse-expr (fn input (fn path (fn position ((with (car input)) (fn head (((((char.= head) open-parentheses) (fn "" ((((((parse-list-expr parse-expr) (cdr input)) path) (next-char position)) (next-char position)) ()))) (fn "" (((((char.= head) quote) (fn "" (((((parse-identifier-literal-expr (cdr input)) path) (next-char position)) (next-char position)) ()))) (fn "" (((((char.= head) semicolon) (fn "" ((((parse-comment parse-expr) (cdr input)) path) (next-char position)))) (fn "" ((((newline? head) (fn "" (((parse-expr (cdr input)) path) (next-line position)))) (fn "" ((((whitespace? head) (fn "" (((parse-expr (cdr input)) path) (next-char position)))) (fn "" (((((parse-identifier-expr input) path) position) position) ()))) ()))) ()))) ()))) ()))) ())))))))
(def parse (fn input (fn path (fn position (fn acc ((((nil? input) (fn "" (reverse acc))) (fn "" (((((char.= linefeed) (car input)) (fn "" ((((parse (cdr input)) path) (next-line position)) acc))) (fn "" ((((whitespace? (car input)) (fn "" ((((parse (cdr input)) path) (next-char position)) acc))) (fn "" ((with (((parse-expr input) path) position)) (fn result ((((parse (parse-result.rest result)) path) (expr.end (parse-result.expr result))) ((cons (parse-result.expr result)) acc)))))) ()))) ()))) ()))))))
(def parse-file (fn file (fn path (fn init ((then-run-with (file.directory? file)) (fn directory? (((directory? (fn "" ((then-run-with (file.child-files file)) (fn child-files (((fold child-files) (impure ())) (fn acc (fn child ((then-run-with (((parse-file child) (((init (fn "" ())) (fn "" ((concat path) ((append (file.name file)) slash)))) ())) false)) (fn parse ((run-with acc) (fn exprs ((concat exprs) parse)))))))))))) (fn "" ((run-with (file.read file)) (fn chars ((((parse chars) ((concat path) (file.name-without-extension file))) ((position nat.1) nat.1)) ()))))) ())))))))
(def repl-parse (fn line (fn index (parse-result.expr (((parse-expr ((append line) linefeed)) ((mangle-fn-name (symbol repl)) index)) ((position index) nat.1))))))
(def local-variable.name ((field (symbol local-variable)) (symbol name)))
(def local-variable.index ((field (symbol local-variable)) (symbol index)))
(def global-variable.name ((field (symbol global-variable)) (symbol name)))
(def global-variable.path ((field (symbol global-variable)) (symbol path)))
(def generate-identifier-expr' (fn variable ((((global-variable? variable) (fn "" ((global-variable-operation (global-variable.name variable)) (global-variable.path variable)))) (fn "" ((local-variable-operation (local-variable.name variable)) (local-variable.index variable)))) ())))
(def global-variable.macro? ((field (symbol global-variable)) (symbol macro?)))
(def tree-map-node.left ((field (symbol tree-map-node)) (symbol left)))
(def tree-map-node.min-node (fn node ((((tree-map-node-nil? (tree-map-node.left node)) (fn "" node)) (fn "" (tree-map-node.min-node (tree-map-node.left node)))) ())))
(def tree-map-node.right ((field (symbol tree-map-node)) (symbol right)))
(def tree-map-node.key ((field (symbol tree-map-node)) (symbol key)))
(def tree-map-node.value ((field (symbol tree-map-node)) (symbol value)))
(def tree-map-node.remove (fn node (fn compare (fn key ((((tree-map-node-nil? node) (fn "" node)) (fn "" ((((fold-compare ((compare key) (tree-map-node.key node))) (fn < ((((tree-map-node (((tree-map-node.remove (tree-map-node.left node)) compare) key)) (tree-map-node.right node)) (tree-map-node.key node)) (tree-map-node.value node)))) (fn > ((((tree-map-node (tree-map-node.left node)) (((tree-map-node.remove (tree-map-node.right node)) compare) key)) (tree-map-node.key node)) (tree-map-node.value node)))) (fn = ((((tree-map-node-nil? (tree-map-node.left node)) (fn "" (tree-map-node.right node))) (fn "" ((((tree-map-node-nil? (tree-map-node.right node)) (fn "" (tree-map-node.left node))) (fn "" ((with (tree-map-node.min-node (tree-map-node.right node))) (fn min ((((tree-map-node (tree-map-node.left node)) (tree-map-node.right (((tree-map-node.remove (tree-map-node.right node)) compare) key))) (tree-map-node.key min)) (tree-map-node.value min)))))) ()))) ()))))) ())))))
(def tree-map-node.get (fn node (fn compare (fn key ((((tree-map-node-nil? node) (fn "" null)) (fn "" ((((fold-compare ((compare key) (tree-map-node.key node))) (fn < (((tree-map-node.get (tree-map-node.left node)) compare) key))) (fn > (((tree-map-node.get (tree-map-node.right node)) compare) key))) (fn = (some (tree-map-node.value node)))))) ())))))
(def tree-map-node.put (fn node (fn compare (fn key (fn value ((((tree-map-node-nil? node) (fn "" ((((tree-map-node tree-map-node-nil) tree-map-node-nil) key) value))) (fn "" ((((fold-compare ((compare key) (tree-map-node.key node))) (fn < ((((tree-map-node ((((tree-map-node.put (tree-map-node.left node)) compare) key) value)) (tree-map-node.right node)) (tree-map-node.key node)) (tree-map-node.value node)))) (fn > ((((tree-map-node (tree-map-node.left node)) ((((tree-map-node.put (tree-map-node.right node)) compare) key) value)) (tree-map-node.key node)) (tree-map-node.value node)))) (fn = ((((tree-map-node (tree-map-node.left node)) (tree-map-node.right node)) key) value))))) ()))))))
(def tree-map-node.fold (fn node (fn acc (fn f ((((tree-map-node-nil? node) (fn "" acc)) (fn "" (((tree-map-node.fold (tree-map-node.right node)) (((f (((tree-map-node.fold (tree-map-node.left node)) acc) f)) (tree-map-node.key node)) (tree-map-node.value node))) f))) ())))))
(def tree-map.node ((field (symbol tree-map)) (symbol node)))
(def tree-map.fold (fn map (fn acc (fn f (((tree-map-node.fold (tree-map.node map)) acc) f)))))
(def tree-map->list (fn map (((tree-map.fold map) ()) (fn list (fn key (fn value ((cons ((pair key) value)) list)))))))
(def tree-map.compare ((field (symbol tree-map)) (symbol compare)))
(def tree-map.remove (fn map (fn key ((tree-map (((tree-map-node.remove (tree-map.node map)) (tree-map.compare map)) key)) (tree-map.compare map)))))
(def tree-map.get (fn map (fn key (((tree-map-node.get (tree-map.node map)) (tree-map.compare map)) key))))
(def env.get (fn local-env (fn global-env (fn name ((with ((tree-map.get (local-env.locals local-env)) name)) (fn option ((((some? option) (fn "" option)) (fn "" ((tree-map.get (global-env.globals global-env)) name))) ())))))))
(def generate-identifier-expr (fn name (fn local-env (fn global-env ((with (((env.get local-env) global-env) name)) (fn option ((((some? option) (fn "" (((generated (generate-identifier-expr' (unnull option))) ()) global-env))) (fn "" (((generating (list1 name)) global-env) (fn global-env (((generate-identifier-expr name) local-env) global-env))))) ())))))))
(def generate-macro?-expr (fn generate-expr (fn expr (fn fn (fn args (fn local-env (fn global-env ((with (identifier-expr.name fn)) (fn name ((with (((env.get local-env) global-env) name)) (fn option ((((null? option) (fn "" (((generating (list1 name)) global-env) (fn global-env (((((generate-macro?-expr expr) fn) args) local-env) global-env))))) (fn "" ((with (unnull option)) (fn variable (((((and (global-variable? variable)) (fn "" (global-variable.macro? variable))) (fn "" ((((((generate-macro-apply-expr generate-expr) expr) name) args) local-env) global-env))) (fn "" (((((generate-apply-expr generate-expr) fn) args) local-env) global-env))) ()))))) ()))))))))))))
(def global-env.unresolved (fn global-env ((filter ((map (tree-map->list (global-env.dependents global-env))) first)) (fn dependent (null? ((tree-map.get (global-env.globals global-env)) dependent))))))
(def tree-map.put (fn map (fn key (fn value ((tree-map ((((tree-map-node.put (tree-map.node map)) (tree-map.compare map)) key) value)) (tree-map.compare map))))))
(def generate-fn-expr-closures (fn closures (fn name (fn local-env (second (((fold ((append closures) name)) ((pair nat.0) (local-env.locals local-env))) (fn vars (fn closure ((pair ((nat.+ nat.1) (first vars))) (((tree-map.put (second vars)) closure) ((local-variable closure) (first vars))))))))))))
(def tree-map.+ (fn map1 (fn map2 (((tree-map.fold map1) map2) (fn map (fn key (fn value (((tree-map.put map) key) value))))))))
(def generate-global-expr (fn macro? (fn generate-expr (fn name (fn value (fn local-env (fn global-env ((((some? ((tree-map.get (global-env.globals global-env)) name)) (fn "" ((degenerate (list1 ((concat name) (symbol " has already been defined")))) global-env))) (fn "" ((with (((swap global-env.with-globals) global-env) (((tree-map.put (global-env.globals global-env)) name) (((global-variable name) (expr.path value)) macro?)))) (fn new-global-env ((((generate-result.match (((generate-expr value) ((local-env.with-def name) local-env)) new-global-env)) (fn degenerate' degenerate')) (fn generating' (((generated (((def-operation name) (expr.path value)) nil-operation)) ()) (((swap global-env.with-dependents) global-env) ((with (global-env.dependents (generating.global-env generating'))) (fn dependents ((with (car (generating.dependencies generating'))) (fn dependency (((tree-map.put dependents) dependency) (fn global-env ((((null? ((tree-map.get dependents) dependency)) (fn "" ((((((generate-global-expr macro?) generate-expr) name) value) local-env) global-env))) (fn "" ((with ((unnull ((tree-map.get dependents) dependency)) global-env)) (fn result1 ((with ((((((generate-global-expr macro?) generate-expr) name) value) local-env) (generate-result.global-env result1))) (fn result2 ((((generate-result.combine result1) result2) (generate-result.global-env result2)) false))))))) ()))))))))))) (fn generated' ((with (((def-declaration name) (expr.path value)) (generated.operation generated'))) (fn declaration ((with ((tree-map.get (global-env.dependents (generated.global-env generated'))) name)) (fn generating? ((with (((generated (((def-operation name) (expr.path value)) (generated.operation generated'))) ((cons declaration) (generated.declarations generated'))) (((swap global-env.with-heap) (generated.global-env generated')) ((interpret-def-declaration declaration) (global-env.heap (generated.global-env generated')))))) (fn result1 ((((null? generating?) (fn "" result1)) (fn "" ((with ((unnull generating?) (generated.global-env result1))) (fn result2 ((((generated.combine result1) result2) (generate-result.global-env result2)) true))))) ()))))))))))))) ()))))))))
(def generate-def-expr (generate-global-expr false))
(def generate-macro-expr (generate-global-expr true))
(def closures' (fn local-env (fn acc (fn expr ((((identifier-expr? expr) (fn "" ((((null? ((tree-map.get (local-env.locals local-env)) (identifier-expr.name expr))) (fn "" acc)) (fn "" (((tree-map.put acc) (identifier-expr.name expr)) true))) ()))) (fn "" (((fold (list-expr.exprs expr)) acc) (closures' local-env)))) ())))))
(def closures (fn local-env ((closures' local-env) (empty-tree-map compare-symbol))))
(def generate-fn-expr (fn generate-expr (fn name (fn value (fn local-env (fn global-env ((with ((mangle-fn-name (local-env.def local-env)) (global-env.index global-env))) (fn mangled-name ((with ((global-env.with-index ((nat.+ nat.1) (global-env.index global-env))) global-env)) (fn new-global-env ((with ((map (tree-map->list ((closures local-env) value))) first)) (fn closures ((((generate-result.match (((generate-expr value) ((local-env.with-locals (((generate-fn-expr-closures closures) name) local-env)) ((local-env.with-def mangled-name) local-env))) new-global-env)) (fn degenerate' degenerate')) (fn generating' (((generating (generating.dependencies generating')) (generating.global-env generating')) (fn global-env ((((generate-fn-expr name) value) local-env) global-env))))) (fn generated' ((with ((((fn-declaration mangled-name) (expr.path value)) closures) (generated.operation generated'))) (fn declaration (((generated (((((fn-operation (expr.path value)) mangled-name) name) (generated.operation generated')) ((map closures) (fn closure (generate-identifier-expr' (unnull (((env.get local-env) (generated.global-env generated')) closure))))))) ((append (generated.declarations generated')) declaration)) (((swap global-env.with-heap) (generated.global-env generated')) ((interpret-fn-declaration declaration) (global-env.heap (generated.global-env generated')))))))))))))))))))))
(def generate-list-expr (fn generate-expr (fn expr (fn local-env (fn global-env ((with (list-expr.exprs expr)) (fn exprs ((((nil? exprs) (fn "" ((generate-nil local-env) global-env))) (fn "" ((((identifier-expr? (car exprs)) (fn "" ((with (identifier-expr.name (car exprs))) (fn name ((((((list.= char.=) name) (symbol->list (symbol if))) (fn "" ((((((generate-if-expr generate-expr) (cadr exprs)) (caddr exprs)) (cadddr exprs)) local-env) global-env))) (fn "" ((((((list.= char.=) name) (symbol->list (symbol fn))) (fn "" (((((generate-fn-expr generate-expr) (identifier-expr.name (cadr exprs))) (caddr exprs)) local-env) global-env))) (fn "" ((((((list.= char.=) name) (symbol->list (symbol def))) (fn "" (((((generate-def-expr generate-expr) (identifier-expr.name (cadr exprs))) (caddr exprs)) local-env) global-env))) (fn "" ((((((list.= char.=) name) (symbol->list (symbol macro))) (fn "" (((((generate-macro-expr generate-expr) (identifier-expr.name (cadr exprs))) (caddr exprs)) local-env) global-env))) (fn "" ((((((list.= char.=) name) (symbol->list (symbol symbol))) (fn "" (((generate-symbol-expr (identifier-expr.name (cadr exprs))) local-env) global-env))) (fn "" ((((((generate-macro?-expr generate-expr) expr) (car exprs)) (cdr exprs)) local-env) global-env))) ()))) ()))) ()))) ()))) ()))))) (fn "" (((((generate-apply-expr generate-expr) (car exprs)) (cdr exprs)) local-env) global-env))) ()))) ()))))))))
(def generate-expr (fn expr (fn local-env (fn global-env ((((generate-result.match ((((identifier-expr? expr) (fn "" (((generate-identifier-expr (identifier-expr.name expr)) local-env) global-env))) (fn "" ((((generate-list-expr generate-expr) expr) local-env) global-env))) ())) (fn degenerate' degenerate')) (fn generating' generating')) (fn generated' (((generated ((line-number-operation (generated.operation generated')) (position.line (expr.start expr)))) (generated.declarations generated')) (generated.global-env generated'))))))))
(def generate-exprs' (fn exprs (fn result ((((nil? exprs) (fn "" result)) (fn "" ((with (((generate-expr (car exprs)) default-local-env) (generate-result.global-env result))) (fn car-result ((generate-exprs' (cdr exprs)) ((((generate-result.combine result) car-result) (generate-result.global-env car-result)) true)))))) ()))))
(def generate-exprs (fn exprs (fn global-env ((generate-exprs' exprs) (((generated nil-operation) ()) global-env)))))
(def mpm-resolve-dependencies (fn resolve (fn resolved (fn result (fn dependencies ((((nil? dependencies) (fn "" (impure ((pair resolved) result)))) (fn "" ((with (mpm-get-ref (car dependencies))) (fn ref-file ((then-run-with (file.exists? ref-file)) (fn is-ref ((((not is-ref) (fn "" ((((mpm-resolve-dependencies resolve) resolved) result) (cdr dependencies)))) (fn "" ((then-run-with (file.read ref-file)) (fn ref ((((some? ((tree-map.get resolved) ref)) (fn "" ((((mpm-resolve-dependencies resolve) resolved) result) (cdr dependencies)))) (fn "" ((then-run-with (((parse-file (mpm-get-src ref)) ()) true)) (fn exprs ((then-run-with ((resolve (((tree-map.put resolved) ref) true)) ((generate-exprs' exprs) result))) (fn pair ((((mpm-resolve-dependencies resolve) (first pair)) (second pair)) (cdr dependencies)))))))) ()))))) ()))))))) ()))))))
(def mpm-resolve-generating (fn resolve (fn resolved (fn generating' ((then-run-with ((((mpm-resolve-dependencies resolve) resolved) generating') (generating.dependencies generating'))) (fn pair ((resolve (first pair)) (second pair))))))))
(def mpm-resolve-generated (fn resolve (fn resolved (fn generated' ((with (global-env.unresolved (generated.global-env generated'))) (fn unresolved ((((nil? unresolved) (fn "" (impure ((pair resolved) generated')))) (fn "" ((then-run-with ((((mpm-resolve-dependencies resolve) resolved) generated') unresolved)) (fn pair ((resolve (first pair)) (second pair)))))) ())))))))
(def mpm-resolve-generate-result' (fn resolved (fn result ((((generate-result.match result) (fn degenerate' (impure ((pair resolved) degenerate')))) ((mpm-resolve-generating mpm-resolve-generate-result') resolved)) ((mpm-resolve-generated mpm-resolve-generate-result') resolved)))))
(def mpm-resolve-generate-result (fn result (((swap run-with) second) ((mpm-resolve-generate-result' (empty-tree-map compare-symbol)) result))))
(def generate (fn in ((then-run-with (((parse-file in) ()) true)) (fn exprs (mpm-resolve-generate-result ((generate-exprs exprs) default-global-env))))))
(def desugar-file (fn in (fn out ((then-run-with (generate in)) (fn result ((with (desugar-declarations (generated.declarations result))) (fn desugared ((file.write out) desugared))))))))
(def compile (fn in (fn out ((then-run-with (generate in)) (fn result ((((generate-result.match result) (fn degenerate' (error (car (degenerate.errors degenerate'))))) (fn generating' (error ((flat-map (generating.dependencies generating')) ((swap append) space))))) (fn generated' ((write-result generated') out))))))))
(def mpm-put (fn in ((then-run-with (generate in)) (fn result ((then-run (mpm-put-refs (generated.declarations result))) (mpm-put-srcs in))))))
(def repl (fn global-env (fn heap (fn index (fn resolved ((then-run-with ((then-run ((ostream.write stdout) (car (symbol >)))) (istream.readln stdin))) (fn line (((((symbol.= ((filter line) ((compose not) whitespace?))) (symbol "")) (fn "" (impure ()))) (fn "" ((with ((char.= (car line)) (car (symbol !)))) (fn !? ((with ((repl-parse ((concat (symbol "(def it ")) ((append (((!? (fn "" (cdr line))) (fn "" line)) ())) close-parentheses))) index)) (fn expr ((then-run-with ((mpm-resolve-generate-result' resolved) (((generate-expr expr) default-local-env) global-env))) (fn pair ((with ((repl-interpret-declarations (second pair)) heap)) (fn new-heap ((with ((repl-interpret-operation (second pair)) new-heap)) (fn value (((((!? (fn "" then-run-with)) (fn "" with)) ()) value) (fn v ((((((const repl) (debug v)) ((global-env.with-globals ((tree-map.remove (global-env.globals (generated.global-env (second pair)))) (symbol it))) (generated.global-env (second pair)))) new-heap) (nat.inc index)) (first pair)))))))))))))))) ()))))))))
(def empty-repl (fn "" ((((repl default-global-env) empty-heap) nat.1) (empty-tree-map compare-symbol))))
(def run-repl (fn in ((then-run-with (generate in)) (fn result ((((repl (generated.global-env result)) ((interpret-declarations (generated.declarations result)) empty-heap)) nat.1) (empty-tree-map compare-symbol))))))
(def "" (fn args ((((nil? args) (fn "" (empty-repl ()))) (fn "" ((with ((file.child file.local-file) (car args))) (fn in ((((nil? (cdr args)) (fn "" (run-repl in))) (fn "" ((with ((file.child file.local-file) (cadr args))) (fn out ((((nil? (cddr args)) (fn "" ((compile in) out))) (fn "" (error (symbol "Usage: mc <in> <out>")))) ()))))) ()))))) ())))
