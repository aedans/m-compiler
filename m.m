(def id (fn x x))
(def const (fn x (fn _ x)))
(def compose (fn f (fn g (fn x (f (g x))))))
(def swap (fn f (fn x (fn y ((f y) x)))))
(def apply (fn f (fn x (f x))))
(def with (swap apply))
(def http/GET (symbol GET))
(def http/HEAD (symbol HEAD))
(def http/POST (symbol POST))
(def http/PUT (symbol PUT))
(def http/PATCH (symbol PATCH))
(def http/DELETE (symbol DELETE))
(def istream.read id)
(def ostream.write (fn ostream (fn char (ostream char))))
(def symbol-expr (fn name (fn path (fn start (fn end (fn f (fn _ (f (fn f ((((f name) path) start) end))))))))))
(def list-expr (fn exprs (fn path (fn start (fn end (fn _ (fn f (f (fn f ((((f exprs) path) start) end))))))))))
(def true (fn x (fn _ x)))
(def false (fn _ (fn x x)))
(def char->nat id)
(def left (fn value (fn f (fn _ (f value)))))
(def result/success (fn expr (left expr)))
(def right (fn value (fn _ (fn f (f value)))))
(def left? (fn either ((either (const true)) (const false))))
(def right? (fn either ((either (const false)) (const true))))
(def nil false)
(def desugar-fn-declaration (const nil))
(def nil? (fn list ((list (const (const (const false)))) true)))
(def nat.0 (fn f (fn x x)))
(def nat.1 (fn f (fn x (f x))))
(def some right)
(def null (left false))
(def empty-heap (const null))
(def some? right?)
(def null? left?)
(def pair (fn first (fn second (fn bool ((bool first) second)))))
(def env/empty (const ((pair ((pair null) null)) false)))
(def position pair)
(def start-position ((position nat.1) nat.1))
(def expr/symbol (fn name ((((symbol-expr name) (symbol expr.m)) start-position) start-position)))
(def expr/list (fn exprs ((((list-expr exprs) (symbol expr.m)) start-position) start-position)))
(def cons pair)
(def first (fn pair (pair true)))
(def position.line first)
(def type-name first)
(def car first)
(def open-parentheses (car (symbol "(")))
(def close-parentheses (car (symbol ")")))
(def semicolon (car (symbol ";")))
(def dot (car (symbol .)))
(def quote (car (symbol """""")))
(def slash (car (symbol /)))
(def backslash (car (symbol \)))
(def space (car (symbol " ")))
(def tab (car (symbol "	")))
(def linefeed (car (symbol "
")))
(def carriage-return (car (symbol "
")))
(def second (fn pair (pair false)))
(def position.char second)
(def cdr second)
(def cddr ((compose cdr) cdr))
(def caddr ((compose car) cddr))
(def cdddr ((compose cdr) cddr))
(def cadddr ((compose car) cdddr))
(def cadr ((compose car) cdr))
(def list (fn env (fn exprs (result/success ((((nil? exprs) (const (expr/symbol (symbol nil)))) (fn _ (expr/list ((cons (expr/symbol (symbol cons))) ((cons (car exprs)) ((cons (expr/list ((cons (expr/symbol (symbol list))) (cdr exprs)))) nil)))))) nil)))))
(def fix (fn f ((fn x (f (fn v ((x x) v)))) (fn x (f (fn v ((x x) v)))))))
(def symbol->list id)
(def delay (fn env (fn exprs (result/success (expr/list ((cons (expr/symbol (symbol fn))) ((cons (expr/symbol (symbol _))) exprs)))))))
(def apply-vararg (fn env (fn exprs (result/success (expr/list ((cons (car exprs)) ((cons (expr/list ((cons (expr/symbol (symbol list))) (cdr exprs)))) nil)))))))
(def if (fn env (fn exprs (result/success (expr/list ((cons (expr/symbol (symbol force))) ((cons (expr/list ((cons (car exprs)) ((cons (expr/list ((cons (expr/symbol (symbol delay))) ((cons (cadr exprs)) nil)))) ((cons (expr/list ((cons (expr/symbol (symbol delay))) ((cons (caddr exprs)) nil)))) nil))))) nil)))))))
(def macrofn (fn env (fn exprs (result/success (expr/list ((cons (expr/symbol (symbol macro))) ((cons (car exprs)) ((cons (expr/list ((cons (expr/symbol (symbol fn))) (cdr exprs)))) nil))))))))
(def & (fn env (fn exprs (result/success (expr/list ((cons (expr/symbol (symbol and))) ((cons (car exprs)) ((cons (expr/list ((cons (expr/symbol (symbol delay))) ((cons (cadr exprs)) nil)))) nil))))))))
(def | (fn env (fn exprs (result/success (expr/list ((cons (expr/symbol (symbol or))) ((cons (car exprs)) ((cons (expr/list ((cons (expr/symbol (symbol delay))) ((cons (cadr exprs)) nil)))) nil))))))))
(def defrec (fn env (fn exprs (result/success (expr/list ((cons (expr/symbol (symbol def))) ((cons (car exprs)) ((cons (expr/list ((cons (expr/symbol (symbol fix))) ((cons (cadr exprs)) nil)))) nil))))))))
(def defnrec (fn env (fn exprs (result/success (expr/list ((cons (expr/symbol (symbol defrec))) ((cons (car exprs)) ((cons (expr/list ((cons (expr/symbol (symbol fn))) exprs))) nil))))))))
(def error (fix (fn error (fn message (fn _ (error message))))))
(def defn (fn env (fn exprs (result/success (expr/list ((cons (expr/symbol (symbol def))) ((cons (car exprs)) ((cons (expr/list ((cons (expr/symbol (symbol fn))) (cdr exprs)))) nil))))))))
(def impure (fn x (fn f (f x))))
(def then-run-with (fn p (fn f (p f))))
(def then-run (fn a (fn b ((then-run-with a) (const b)))))
(def run-with (fn p (fn f ((then-run-with p) ((compose impure) f)))))
(def env/get (fn env (fn name (env name))))
(def env/get-value (fn env (fn name (first (first ((env/get env) name))))))
(def env/get-def (fn env (fn name (second (first ((env/get env) name))))))
(def env/get-macro? (fn env (fn name (second ((env/get env) name)))))
(def expr.match (fn expr (fn symbol-fn (fn list-fn ((expr (fn symbol-expr (symbol-expr symbol-fn))) (fn list-expr (list-expr list-fn)))))))
(def expr.path (fn expr (((expr.match expr) (fn _ (fn path (fn _ (fn _ path))))) (fn _ (fn path (fn _ (fn _ path)))))))
(def expr.start (fn expr (((expr.match expr) (fn _ (fn _ (fn start (fn _ start))))) (fn _ (fn _ (fn start (fn _ start)))))))
(def expr.end (fn expr (((expr.match expr) (fn _ (fn _ (fn _ (fn end end))))) (fn _ (fn _ (fn _ (fn end end)))))))
(def result/error (fn error (right (left error))))
(def result/depends (fn dependencies (right (right dependencies))))
(def result/match (fn result (fn success (fn error (fn depends ((result success) (fn fail ((fail error) depends))))))))
(def nat.0? (fn n ((n (const true)) false)))
(def nat.inc (fn n (fn f (fn x (f ((n f) x))))))
(def nat.dec (fn n (fn f (fn x (((n (fn g (fn h (h (g f))))) (const x)) id)))))
(def unnull (fn either ((either id) id)))
(def extern (fn env (fn exprs (result/success (expr/list ((cons (expr/symbol (symbol def))) ((cons (car exprs)) ((cons (car exprs)) nil))))))))
(def jvm-backend jvm-backend)
(def mangle-fn-name mangle-fn-name)
(def file.from-path file.from-path)
(def file.local-file (file.from-path (symbol .)))
(def file.name file.name)
(def file.name-without-extension file.name-without-extension)
(def file.child file.child)
(def file.exists? file.exists?)
(def file.read file.read)
(def file.write file.write)
(def file.directory? file.directory?)
(def file.child-files file.child-files)
(def file.copy file.copy)
(def http/send http/send)
(def http/get (fn url (fn headers (fn body ((((http/send http/GET) url) headers) body)))))
(def http/head (fn url (fn headers (fn body ((((http/send http/HEAD) url) headers) body)))))
(def http/post (fn url (fn headers (fn body ((((http/send http/POST) url) headers) body)))))
(def http/put (fn url (fn headers (fn body ((((http/send http/PUT) url) headers) body)))))
(def http/patch (fn url (fn headers (fn body ((((http/send http/PATCH) url) headers) body)))))
(def http/delete (fn url (fn headers (fn body ((((http/send http/DELETE) url) headers) body)))))
(def stdout stdout)
(def stderr stderr)
(def stdin stdin)
(def debug debug)
(def force (fn env (fn exprs (result/success (expr/list ((cons (car exprs)) ((cons (expr/symbol (symbol nil))) nil)))))))
(def do (fn env (fn exprs (result/success ((((nil? (cdr exprs)) (fn _ (car exprs))) (fn _ (expr/list ((cons (expr/symbol (symbol then-run-with))) ((cons (cadr exprs)) ((cons (expr/list ((cons (expr/symbol (symbol fn))) ((cons (car exprs)) ((cons (expr/list ((cons (expr/symbol (symbol do))) (cddr exprs)))) nil))))) nil)))))) nil)))))
(def process/sequence (fn list ((then-run-with (car list)) (fn head ((then-run-with (process/sequence (cdr list))) (fn tail (impure ((cons head) tail))))))))
(def init (fix (fn init (fn list ((((nil? (cdr list)) (fn _ nil)) (fn _ ((cons (car list)) (init (cdr list))))) nil)))))
(def last (fix (fn last (fn list ((((nil? (cdr list)) (fn _ (car list))) (fn _ (last (cdr list)))) nil)))))
(def append (fix (fn append (fn list (fn elem ((((nil? list) (fn _ ((cons elem) nil))) (fn _ ((cons (car list)) ((append (cdr list)) elem)))) nil))))))
(def concat (fix (fn concat (fn a (fn b ((((nil? a) (fn _ b)) (fn _ ((cons (car a)) ((concat (cdr a)) b)))) nil))))))
(def symbol.+ concat)
(def object (fn type ((pair type) (fn name ((concat (symbol->list (symbol "Could not find field "))) ((concat (symbol->list name)) ((concat (symbol->list (symbol " for "))) (symbol->list type))))))))
(def compare= (object (symbol compare=)))
(def compare< (object (symbol compare<)))
(def compare> (object (symbol compare>)))
(def get (fix (fn get (fn list (fn n ((((nat.0? n) (fn _ (car list))) (fn _ ((get (cdr list)) (nat.dec n)))) nil))))))
(def map (fix (fn map (fn list (fn f ((((nil? list) (fn _ nil)) (fn _ ((cons (f (car list))) ((map (cdr list)) f)))) nil))))))
(def expr.with-path (fix (fn expr.with-path (fn path (fn expr (((expr.match expr) (fn name (fn _ (fn start (fn end ((((symbol-expr name) path) start) end)))))) (fn exprs (fn _ (fn start (fn end ((((list-expr ((map exprs) (expr.with-path path))) path) start) end)))))))))))
(def flat-map (fix (fn flat-map (fn list (fn f ((((nil? list) (fn _ nil)) (fn _ ((concat (f (car list))) ((flat-map (cdr list)) f)))) nil))))))
(def filter (fix (fn filter (fn list (fn f ((((nil? list) (fn _ nil)) (fn _ ((((f (car list)) (fn _ ((cons (car list)) ((filter (cdr list)) f)))) (fn _ ((filter (cdr list)) f))) nil))) nil))))))
(def fold (fix (fn fold (fn list (fn acc (fn f ((((nil? list) (fn _ acc)) (fn _ (((fold (cdr list)) ((f acc) (car list))) f))) nil)))))))
(def reverse' (fix (fn reverse' (fn list (fn acc ((((nil? list) (fn _ acc)) (fn _ ((reverse' (cdr list)) ((cons (car list)) acc)))) nil))))))
(def reverse (fn list ((reverse' list) nil)))
(def nat.+ (fix (fn nat.+ (fn a (fn b ((((nat.0? b) (fn _ a)) (fn _ ((nat.+ (nat.inc a)) (nat.dec b)))) nil))))))
(def next-char (fn p ((position (position.line p)) ((nat.+ nat.1) (position.char p)))))
(def next-line (fn p ((position ((nat.+ nat.1) (position.line p))) nat.1)))
(def nat.- (fix (fn nat.- (fn a (fn b ((((nat.0? b) (fn _ a)) (fn _ ((nat.- (nat.dec a)) (nat.dec b)))) nil))))))
(def match-fn-expr' (fn exprs (fn names (fn invalid-arg (fn success ((((nil? (cdr exprs)) (fn _ ((success (reverse names)) (car exprs)))) (fn _ (((expr.match (car exprs)) (fn name (fn _ (fn _ (fn _ ((((match-fn-expr' (cdr exprs)) ((cons name) names)) invalid-arg) success)))))) (fn _ (fn _ (fn _ (fn _ (invalid-arg (car exprs))))))))) nil))))))
(def match-fn-expr (fn exprs (fn no-expr (fn no-args (fn invalid-arg (fn success ((((nil? exprs) (fn _ no-expr)) (fn _ ((((nil? (cdr exprs)) (fn _ no-args)) (fn _ ((((match-fn-expr' exprs) nil) invalid-arg) success))) nil))) nil)))))))
(def match-apply-expr (fn exprs (fn no-args (fn success ((((nil? (cdr exprs)) (fn _ no-args)) (fn _ success)) nil)))))
(def ostream.writeln (fn ostream (fn line ((((nil? line) (fn _ ((ostream.write ostream) linefeed))) (fn _ ((then-run ((ostream.write ostream) (car line))) ((ostream.writeln ostream) (cdr line))))) nil))))
(def and (fn x (fn y (((x (fn _ (y nil))) (fn _ false)) nil))))
(def or (fn x (fn y (((x (fn _ true)) (fn _ (y nil))) nil))))
(def not (fn x (((x (fn _ false)) (fn _ true)) nil)))
(def match-def-expr (fn exprs (fn no-name (fn no-expr (fn extra-exprs (fn invalid-name (fn success ((((nil? exprs) (fn _ no-name)) (fn _ ((((nil? (cdr exprs)) (fn _ no-expr)) (fn _ ((((not (nil? (cddr exprs))) (fn _ extra-exprs)) (fn _ (((expr.match (car exprs)) (fn name (fn _ (fn _ (fn _ ((success name) (cadr exprs))))))) (fn _ (fn _ (fn _ (fn _ (invalid-name (car exprs))))))))) nil))) nil))) nil))))))))
(def match-macro-expr match-def-expr)
(def match-symbol-literal-expr (fn exprs (fn no-symbol (fn extra-exprs (fn invalid-symbol (fn success ((((nil? exprs) (fn _ no-symbol)) (fn _ ((((not (nil? (cdr exprs))) (fn _ extra-exprs)) (fn _ (((expr.match (car exprs)) (fn name (fn _ (fn _ (fn _ (success name)))))) (fn _ (fn _ (fn _ (fn _ (invalid-symbol (car exprs))))))))) nil))) nil)))))))
(def let (fn env (fn exprs (result/success ((((nil? (cdr exprs)) (fn _ (car exprs))) (fn _ (expr/list ((cons (expr/symbol (symbol with))) ((cons (cadr exprs)) ((cons (expr/list ((cons (expr/symbol (symbol fn))) ((cons (car exprs)) ((cons (expr/list ((cons (expr/symbol (symbol let))) (cddr exprs)))) nil))))) nil)))))) nil)))))
(def heap.get (fn heap (fn name ((with (heap name)) (fn value ((((null? value) (fn _ (error ((concat (symbol->list (symbol "Could not find "))) name)))) (fn _ ((unnull value) heap))) nil))))))
(def macro-call-expr (fn env (fn exprs ((((nil? exprs) (fn _ (result/error (symbol "No exprs passed to macro-call-expr")))) (fn _ (result/success (expr/list ((cons (expr/symbol (symbol expr/list))) ((cons (expr/list ((cons (expr/symbol (symbol cons))) ((cons (expr/list ((cons (expr/symbol (symbol expr/symbol))) ((cons (expr/list ((cons (expr/symbol (symbol symbol))) ((cons (car exprs)) nil)))) nil)))) ((cons (cadr exprs)) nil))))) nil)))))) nil))))
(def cond (fn env (fn exprs ((((nil? exprs) (fn _ (result/error (symbol "No exprs passed to cond")))) (fn _ ((((nil? (cdr exprs)) (fn _ (result/success (car exprs)))) (fn _ ((((nil? (cddr exprs)) (fn _ (result/error (symbol "No else case for cond")))) (fn _ (result/success (expr/list ((cons (expr/symbol (symbol if))) ((cons (car exprs)) ((cons (cadr exprs)) ((cons (expr/list ((cons (expr/symbol (symbol cond))) (cddr exprs)))) nil)))))))) nil))) nil))) nil))))
(def list.= (fix (fn list.= (fn = (fn a (fn b ((((nil? a) (fn _ (nil? b))) (fn _ ((((nil? b) (fn _ false)) (fn _ ((and ((= (car a)) (car b))) (fn _ (((list.= =) (cdr a)) (cdr b)))))) nil))) nil)))))))
(def nat.< (fix (fn nat.< (fn a (fn b ((((nat.0? a) (fn _ (not (nat.0? b)))) (fn _ ((((nat.0? b) (fn _ false)) (fn _ ((nat.< (nat.dec a)) (nat.dec b)))) nil))) nil))))))
(def nat.> (swap nat.<))
(def nat.= (fix (fn nat.= (fn a (fn b ((((nat.0? a) (fn _ (nat.0? b))) (fn _ ((((nat.0? b) (fn _ false)) (fn _ ((nat.= (nat.dec a)) (nat.dec b)))) nil))) nil))))))
(def char.= nat.=)
(def newline? (fn char ((or ((char.= char) linefeed)) (fn _ ((char.= char) carriage-return)))))
(def parse-comment (fix (fn parse-comment (fn path (fn input (fn position (fn continue (((((or (nil? input)) (fn _ (newline? (car input)))) (fn _ (((continue path) input) position))) (fn _ ((((parse-comment path) (cdr input)) (next-char position)) continue))) nil))))))))
(def istream.readln (fn istream ((then-run-with istream) (fn char (((((char.= linefeed) char) (fn _ (impure nil))) (fn _ ((then-run-with (istream.readln istream)) (fn line (impure ((((newline? char) (fn _ line)) (fn _ ((cons char) line))) nil)))))) nil)))))
(def whitespace? (fn char ((or ((char.= char) space)) (fn _ ((or ((char.= char) tab)) (fn _ (newline? char)))))))
(def separator? (fn char ((or (whitespace? char)) (fn _ ((or ((char.= char) open-parentheses)) (fn _ ((or ((char.= char) close-parentheses)) (fn _ ((or ((char.= char) semicolon)) (fn _ ((char.= char) quote)))))))))))
(def parse-symbol (fix (fn parse-symbol (fn path (fn input (fn position (fn continue ((with (car input)) (fn head (((((or (nil? input)) (fn _ (separator? head))) (fn _ ((((continue nil) path) input) position))) (fn _ ((((parse-symbol path) (cdr input)) (next-char position)) (fn chars (fn path (fn input (fn position ((((continue ((cons head) chars)) path) input) position)))))))) nil))))))))))
(def desugar-should-quote? (fix (fn desugar-should-quote? (fn name ((((nil? name) (fn _ false)) (fn _ ((with (car name)) (fn char ((or ((char.= char) quote)) (fn _ ((or ((char.= char) open-parentheses)) (fn _ ((or ((char.= char) close-parentheses)) (fn _ ((or ((char.= char) semicolon)) (fn _ ((or (whitespace? char)) (fn _ (desugar-should-quote? (cdr name)))))))))))))))) nil)))))
(def parse-symbol-literal (fix (fn parse-symbol-literal (fn path (fn input (fn position (fn continue ((((nil? input) (fn _ (error (symbol "Unexpected end of file")))) (fn _ ((with (car input)) (fn head (((((char.= head) quote) (fn _ (((((char.= (cadr input)) quote) (fn _ ((((parse-symbol-literal path) (cdr input)) (next-char (next-char position))) (fn chars (fn path (fn input (fn position ((((continue ((cons quote) chars)) path) input) position)))))))) (fn _ ((((continue nil) path) (cdr input)) (next-char position)))) nil))) (fn _ ((((parse-symbol-literal path) (cdr input)) ((((((char.= head) linefeed) (fn _ next-line)) (fn _ next-char)) nil) position)) (fn chars (fn path (fn input (fn position ((((continue ((cons head) chars)) path) input) position)))))))) nil))))) nil))))))))
(def desugar-quote' (fix (fn desugar-quote' (fn name ((((nil? name) (fn _ name)) (fn _ (((((char.= quote) (car name)) (fn _ ((cons quote) ((cons quote) (desugar-quote' (cdr name)))))) (fn _ ((cons (car name)) (desugar-quote' (cdr name))))) nil))) nil)))))
(def desugar-quote (fn name (((((or (desugar-should-quote? name)) (fn _ (nil? name))) (fn _ ((cons quote) (((swap append) quote) (desugar-quote' name))))) (fn _ name)) nil)))
(def symbol.= (list.= char.=))
(def is? (fn type (fn data ((symbol.= type) (type-name data)))))
(def def-declaration? (is? (symbol def-declaration)))
(def fn-declaration? (is? (symbol fn-declaration)))
(def generating? (is? (symbol generating)))
(def generated? (is? (symbol generated)))
(def degenerate? (is? (symbol degenerate)))
(def generate-result.match (fn result (fn degenerate' (fn generating' (fn generated' ((((generated? result) (fn _ (generated' result))) (fn _ ((((generating? result) (fn _ (generating' result))) (fn _ ((((degenerate? result) (fn _ (degenerate' result))) (fn _ (error (symbol ...)))) nil))) nil))) nil))))))
(def local-variable? (is? (symbol local-variable)))
(def global-variable? (is? (symbol global-variable)))
(def compare=? (is? (symbol compare=)))
(def compare-list (fix (fn compare-list (fn compare (fn a (fn b (((((and (nil? a)) (fn _ (nil? b))) (fn _ compare=)) (fn _ ((((nil? a) (fn _ compare<)) (fn _ ((((nil? b) (fn _ compare>)) (fn _ ((with ((compare (car a)) (car b))) (fn compare-result ((((compare=? compare-result) (fn _ (((compare-list compare) (cdr a)) (cdr b)))) (fn _ compare-result)) nil))))) nil))) nil))) nil)))))))
(def compare<? (is? (symbol compare<)))
(def compare>? (is? (symbol compare>)))
(def as (fn type (fn data (((((is? type) data) (fn _ data)) (fn _ (error ((concat (symbol->list (symbol "Could not cast "))) ((concat (symbol->list (type-name data))) ((concat (symbol->list (symbol " to "))) (symbol->list type))))))) nil))))
(def field (fn type (fn name (fn data ((second ((as type) data)) name)))))
(def def-declaration.name ((field (symbol def-declaration)) (symbol name)))
(def def-declaration.path ((field (symbol def-declaration)) (symbol path)))
(def def-declaration.value ((field (symbol def-declaration)) (symbol value)))
(def fn-declaration.name ((field (symbol fn-declaration)) (symbol name)))
(def declaration.name (fn declaration ((((def-declaration? declaration) (fn _ (def-declaration.name declaration))) (fn _ (fn-declaration.name declaration))) nil)))
(def fn-declaration.path ((field (symbol fn-declaration)) (symbol path)))
(def fn-declaration.closures ((field (symbol fn-declaration)) (symbol closures)))
(def fn-declaration.value ((field (symbol fn-declaration)) (symbol value)))
(def declaration.value (fn declaration ((((def-declaration? declaration) (fn _ (def-declaration.value declaration))) (fn _ (fn-declaration.value declaration))) nil)))
(def local-env.locals ((field (symbol local-env)) (symbol locals)))
(def local-env.def ((field (symbol local-env)) (symbol def)))
(def global-env.globals ((field (symbol global-env)) (symbol globals)))
(def global-env.heap ((field (symbol global-env)) (symbol heap)))
(def global-env.dependents ((field (symbol global-env)) (symbol dependents)))
(def global-env.index ((field (symbol global-env)) (symbol index)))
(def local-variable-operation.name ((field (symbol local-variable-operation)) (symbol name)))
(def desugar-local-variable-operation (fn desugar-operation (fn operation (desugar-quote (local-variable-operation.name operation)))))
(def local-variable-operation.index ((field (symbol local-variable-operation)) (symbol index)))
(def interpret-local-variable-operation (fn interpret-operation' (fn operation (fn stack (fn heap ((get stack) (local-variable-operation.index operation)))))))
(def global-variable-operation.name ((field (symbol global-variable-operation)) (symbol name)))
(def interpret-global-variable-operation (fn interpret-operation' (fn operation (fn stack (fn heap ((heap.get heap) (global-variable-operation.name operation)))))))
(def desugar-global-variable-operation (fn desugar-operation (fn operation (desugar-quote (global-variable-operation.name operation)))))
(def global-variable-operation.path ((field (symbol global-variable-operation)) (symbol path)))
(def def-operation.name ((field (symbol def-operation)) (symbol name)))
(def desugar-def-operation (fn desugar-operation (fn operation (def-operation.name operation))))
(def interpret-def-operation (fn interpret-operation' (fn operation (fn stack (fn heap ((heap.get heap) (def-operation.name operation)))))))
(def def-operation.path ((field (symbol def-operation)) (symbol path)))
(def def-operation.value ((field (symbol def-operation)) (symbol value)))
(def fn-operation.path ((field (symbol fn-operation)) (symbol path)))
(def fn-operation.name ((field (symbol fn-operation)) (symbol name)))
(def fn-operation.arg ((field (symbol fn-operation)) (symbol arg)))
(def fn-operation.value ((field (symbol fn-operation)) (symbol value)))
(def desugar-fn-operation (fn desugar-operation (fn operation ((concat (symbol "(fn ")) ((concat (desugar-quote (fn-operation.arg operation))) ((concat (symbol " ")) ((concat (desugar-operation (fn-operation.value operation))) (symbol ")"))))))))
(def fn-operation.closures ((field (symbol fn-operation)) (symbol closures)))
(def interpret-fn-operation (fn interpret-operation' (fn operation (fn stack (fn heap (fn arg (((heap.get heap) (fn-operation.name operation)) ((concat ((map (fn-operation.closures operation)) (fn closure (((interpret-operation' closure) stack) heap)))) ((cons arg) stack)))))))))
(def symbol-operation.name ((field (symbol symbol-operation)) (symbol name)))
(def interpret-symbol-operation (fn interpret-operation' (fn operation (fn stack (fn heap (symbol-operation.name operation))))))
(def desugar-symbol-operation (fn desugar-operation (fn operation ((concat (symbol "(symbol ")) ((concat (desugar-quote (symbol-operation.name operation))) (symbol ")"))))))
(def apply-operation.fn ((field (symbol apply-operation)) (symbol fn)))
(def apply-operation.arg ((field (symbol apply-operation)) (symbol arg)))
(def interpret-apply-operation (fn interpret-operation' (fn operation (fn stack (fn heap ((((interpret-operation' (apply-operation.fn operation)) stack) heap) (((interpret-operation' (apply-operation.arg operation)) stack) heap)))))))
(def desugar-apply-operation (fn desugar-operation (fn operation ((concat (symbol "(")) ((concat (desugar-operation (apply-operation.fn operation))) ((concat (symbol " ")) ((concat (desugar-operation (apply-operation.arg operation))) (symbol ")"))))))))
(def line-number-operation.operation ((field (symbol line-number-operation)) (symbol operation)))
(def desugar-line-number-operation (fn desugar-operation (fn operation (desugar-operation (line-number-operation.operation operation)))))
(def interpret-line-number-operation (fn interpret-operation' (fn operation (interpret-operation' (line-number-operation.operation operation)))))
(def line-number-operation.line ((field (symbol line-number-operation)) (symbol line)))
(def generating.dependencies ((field (symbol generating)) (symbol dependencies)))
(def generating.global-env ((field (symbol generating)) (symbol global-env)))
(def generating.continue ((field (symbol generating)) (symbol continue)))
(def generated.operation ((field (symbol generated)) (symbol operation)))
(def generated.declarations ((field (symbol generated)) (symbol declarations)))
(def generated.global-env ((field (symbol generated)) (symbol global-env)))
(def degenerate.errors ((field (symbol degenerate)) (symbol errors)))
(def degenerate.global-env ((field (symbol degenerate)) (symbol global-env)))
(def generate-result.global-env (fn result ((((generate-result.match result) degenerate.global-env) generating.global-env) generated.global-env)))
(def local-variable.name ((field (symbol local-variable)) (symbol name)))
(def local-variable.index ((field (symbol local-variable)) (symbol index)))
(def global-variable.name ((field (symbol global-variable)) (symbol name)))
(def global-variable.path ((field (symbol global-variable)) (symbol path)))
(def global-variable.macro? ((field (symbol global-variable)) (symbol macro?)))
(def env/put (fn env (fn name (fn value (fn def (fn macro? (fn n (((((symbol.= name) n) (fn _ ((pair ((pair value) def)) macro?))) (fn _ ((env/get env) n))) nil))))))))
(def derive (fn data (fn name (fn value ((pair (first data)) (fn field (((((symbol.= field) name) (fn _ value)) (fn _ ((second data) field))) nil)))))))
(def data (fn type (fn fields (((fold fields) (object type)) (fn data (fn field (((derive data) (first field)) (second field))))))))
(def new-data' (fix (fn new-data' (fn type (fn names (fn fields ((((nil? names) (fn _ ((data type) fields))) (fn _ (fn value (((new-data' type) (cdr names)) ((cons ((pair (car names)) value)) fields))))) nil)))))))
(def new-data (fn type (fn names (((new-data' type) names) nil))))
(def def-declaration ((new-data (symbol def-declaration)) ((cons (symbol name)) ((cons (symbol path)) ((cons (symbol value)) nil)))))
(def fn-declaration ((new-data (symbol fn-declaration)) ((cons (symbol name)) ((cons (symbol path)) ((cons (symbol closures)) ((cons (symbol value)) nil))))))
(def local-env ((new-data (symbol local-env)) ((cons (symbol locals)) ((cons (symbol def)) nil))))
(def local-env.with-locals (fn locals (fn e ((local-env locals) (local-env.def e)))))
(def local-env.with-def (fn def (fn e ((local-env (local-env.locals e)) def))))
(def global-env ((new-data (symbol global-env)) ((cons (symbol globals)) ((cons (symbol heap)) ((cons (symbol dependents)) ((cons (symbol index)) nil))))))
(def global-env.with-globals (fn globals (fn e ((((global-env globals) (global-env.heap e)) (global-env.dependents e)) (global-env.index e)))))
(def global-env.with-heap (fn heap (fn e ((((global-env (global-env.globals e)) heap) (global-env.dependents e)) (global-env.index e)))))
(def global-env.with-dependents (fn dependents (fn e ((((global-env (global-env.globals e)) (global-env.heap e)) dependents) (global-env.index e)))))
(def global-env.with-index (fn index (fn e ((((global-env (global-env.globals e)) (global-env.heap e)) (global-env.dependents e)) index))))
(def local-variable-operation ((new-data (symbol local-variable-operation)) ((cons (symbol name)) ((cons (symbol index)) nil))))
(def global-variable-operation ((new-data (symbol global-variable-operation)) ((cons (symbol name)) ((cons (symbol path)) nil))))
(def generate-symbol-expr' (fn variable ((((global-variable? variable) (fn _ ((global-variable-operation (global-variable.name variable)) (global-variable.path variable)))) (fn _ ((local-variable-operation (local-variable.name variable)) (local-variable.index variable)))) nil)))
(def def-operation ((new-data (symbol def-operation)) ((cons (symbol name)) ((cons (symbol path)) ((cons (symbol value)) nil)))))
(def fn-operation ((new-data (symbol fn-operation)) ((cons (symbol path)) ((cons (symbol name)) ((cons (symbol arg)) ((cons (symbol value)) ((cons (symbol closures)) nil)))))))
(def symbol-operation ((new-data (symbol symbol-operation)) ((cons (symbol name)) nil)))
(def nil-operation (symbol-operation nil))
(def apply-operation ((new-data (symbol apply-operation)) ((cons (symbol fn)) ((cons (symbol arg)) nil))))
(def line-number-operation ((new-data (symbol line-number-operation)) ((cons (symbol operation)) ((cons (symbol line)) nil))))
(def generating ((new-data (symbol generating)) ((cons (symbol dependencies)) ((cons (symbol global-env)) ((cons (symbol continue)) nil)))))
(def generated-resolve-generating (fn generated.combine (fn generated' (fn generating' (fn global-env (fn f (((generating (generating.dependencies generating')) global-env) (fn global-env ((((generated.combine generated') ((generating.continue generating') global-env)) global-env) f)))))))))
(def generated ((new-data (symbol generated)) ((cons (symbol operation)) ((cons (symbol declarations)) ((cons (symbol global-env)) nil)))))
(def generate-symbol-literal-expr (fn name (fn local-env (fn global-env (((generated (symbol-operation name)) nil) global-env)))))
(def degenerate ((new-data (symbol degenerate)) ((cons (symbol errors)) ((cons (symbol global-env)) nil))))
(def degenerate.with-global-env (fn env (fn degenerate' ((degenerate (degenerate.errors degenerate')) env))))
(def generated.combine (fix (fn generated.combine (fn generated1 (fn result (fn global-env (fn f ((((generate-result.match result) (fn degenerate2 ((degenerate.with-global-env global-env) degenerate2))) (fn generating2 (((((generated-resolve-generating generated.combine) generated1) generating2) global-env) f))) (fn generated2 (((generated ((f (generated.operation generated1)) (generated.operation generated2))) ((concat (generated.declarations generated1)) (generated.declarations generated2))) global-env))))))))))
(def generating.combine (fix (fn generating.combine (fn generating1 (fn result (fn global-env (fn f ((((generate-result.match result) (fn degenerate2 ((degenerate.with-global-env global-env) degenerate2))) (fn generating2 (((generating ((concat (generating.dependencies generating1)) (generating.dependencies generating2))) global-env) (fn global-env ((((generating.combine generating1) generating2) global-env) f))))) (fn generated2 (((((generated-resolve-generating generated.combine) generated2) generating1) global-env) (swap f)))))))))))
(def degenerate.combine (fn degenerate1 (fn result (fn global-env (fn f ((((generate-result.match result) (fn degenerate2 ((degenerate ((concat (degenerate.errors degenerate1)) (degenerate.errors degenerate2))) global-env))) (fn generating2 ((degenerate.with-global-env global-env) degenerate1))) (fn generated2 ((degenerate.with-global-env global-env) degenerate1))))))))
(def generate-result.combine (fn result1 (fn result2 (fn global-env (fn f ((((generate-result.match result1) (fn degenerate1 ((((degenerate.combine degenerate1) result2) global-env) f))) (fn generating1 ((((generating.combine generating1) result2) global-env) f))) (fn generated1 ((((generated.combine generated1) result2) global-env) f))))))))
(def generate-apply-expr' (fn fn-result (fn arg-result ((((generate-result.combine fn-result) arg-result) (generate-result.global-env arg-result)) apply-operation))))
(def generate-apply-expr (fn generate-expr (fn fn (fn args (fn local-env (fn global-env ((with (((generate-expr fn) local-env) global-env)) (fn fn-result (((fold args) fn-result) (fn fn-result (fn arg ((with (((generate-expr arg) local-env) (generate-result.global-env fn-result))) (fn arg-result ((generate-apply-expr' fn-result) arg-result))))))))))))))
(def local-variable ((new-data (symbol local-variable)) ((cons (symbol name)) ((cons (symbol index)) nil))))
(def global-variable ((new-data (symbol global-variable)) ((cons (symbol name)) ((cons (symbol path)) ((cons (symbol macro?)) nil)))))
(def fold-compare (fn compare (fn < (fn > (fn = ((((compare<? compare) (fn _ (< compare))) (fn _ ((((compare>? compare) (fn _ (> compare))) (fn _ (= compare))) nil))) nil))))))
(def compare-nat (fn a (fn b (((((nat.> a) b) (fn _ compare>)) (fn _ (((((nat.< a) b) (fn _ compare<)) (fn _ compare=)) nil))) nil))))
(def compare-char (fn a (fn b ((compare-nat (char->nat a)) (char->nat b)))))
(def compare-symbol (fn a (fn b (((compare-list compare-char) a) b))))
(def pcond (fn env (fn exprs ((((nil? exprs) (fn _ (result/error (symbol "No exprs passed to pcond")))) (fn _ ((with (car exprs)) (fn predicate ((with (cdr exprs)) (fn vals ((((nil? vals) (fn _ (result/error (symbol "No values after predicate for pcond")))) (fn _ ((((nil? (cdr vals)) (fn _ (result/success (car vals)))) (fn _ (result/success (expr/list ((cons (expr/symbol (symbol if))) ((cons (expr/list ((cons predicate) ((cons (car vals)) nil)))) ((cons (cadr vals)) ((cons (expr/list ((cons (expr/symbol (symbol pcond))) ((cons predicate) (cddr vals))))) nil)))))))) nil))) nil))))))) nil))))
(def desugar-operation (fix (fn desugar-operation (fn operation ((((with (type-name operation)) (fn type (((((symbol.= type) (symbol local-variable-operation)) (fn _ desugar-local-variable-operation)) (fn _ (((((symbol.= type) (symbol global-variable-operation)) (fn _ desugar-global-variable-operation)) (fn _ (((((symbol.= type) (symbol def-operation)) (fn _ desugar-def-operation)) (fn _ (((((symbol.= type) (symbol fn-operation)) (fn _ desugar-fn-operation)) (fn _ (((((symbol.= type) (symbol symbol-operation)) (fn _ desugar-symbol-operation)) (fn _ (((((symbol.= type) (symbol apply-operation)) (fn _ desugar-apply-operation)) (fn _ (((((symbol.= type) (symbol line-number-operation)) (fn _ desugar-line-number-operation)) (fn _ (error (symbol ...)))) nil))) nil))) nil))) nil))) nil))) nil))) nil))) desugar-operation) operation)))))
(def desugar-def-declaration (fn declaration ((concat (symbol "(def ")) ((concat (desugar-quote (def-declaration.name declaration))) ((concat (symbol " ")) ((concat (desugar-operation (def-declaration.value declaration))) ((append (symbol ")")) linefeed)))))))
(def desugar-declaration (fn declaration (((with (type-name declaration)) (fn type (((((symbol.= type) (symbol def-declaration)) (fn _ desugar-def-declaration)) (fn _ (((((symbol.= type) (symbol fn-declaration)) (fn _ desugar-fn-declaration)) (fn _ (error (symbol ...)))) nil))) nil))) declaration)))
(def desugar-declarations (fn declarations ((flat-map declarations) desugar-declaration)))
(def m-backend (fn out (fn operation (fn declarations ((with (desugar-declarations declarations)) (fn desugared ((file.write out) desugared)))))))
(def get-backend (fn name (((((symbol.= name) (symbol m)) (fn _ m-backend)) (fn _ (((((symbol.= name) (symbol jvm)) (fn _ jvm-backend)) (fn _ (error ((concat (symbol "Could not find backend ")) name)))) nil))) nil)))
(def interpret-operation' (fix (fn interpret-operation' (fn operation (fn stack (fn heap ((((((with (type-name operation)) (fn type (((((symbol.= type) (symbol local-variable-operation)) (fn _ interpret-local-variable-operation)) (fn _ (((((symbol.= type) (symbol global-variable-operation)) (fn _ interpret-global-variable-operation)) (fn _ (((((symbol.= type) (symbol def-operation)) (fn _ interpret-def-operation)) (fn _ (((((symbol.= type) (symbol fn-operation)) (fn _ interpret-fn-operation)) (fn _ (((((symbol.= type) (symbol symbol-operation)) (fn _ interpret-symbol-operation)) (fn _ (((((symbol.= type) (symbol apply-operation)) (fn _ interpret-apply-operation)) (fn _ (((((symbol.= type) (symbol line-number-operation)) (fn _ interpret-line-number-operation)) (fn _ (error (symbol ...)))) nil))) nil))) nil))) nil))) nil))) nil))) nil))) interpret-operation') operation) stack) heap)))))))
(def interpret-operation (fn operation (fn heap (((interpret-operation' operation) nil) heap))))
(def interpret-def-declaration (fn declaration (fn heap (fn name (((((symbol.= name) (def-declaration.name declaration)) (fn _ (some (fn heap' ((interpret-operation (def-declaration.value declaration)) heap'))))) (fn _ (heap name))) nil)))))
(def generate-global-expr' (fn name (fn value (fn declaration (fn generated' (((generated (((def-operation name) (expr.path value)) (generated.operation generated'))) ((append (generated.declarations generated')) declaration)) (((swap global-env.with-heap) (generated.global-env generated')) ((interpret-def-declaration declaration) (global-env.heap (generated.global-env generated'))))))))))
(def interpret-fn-declaration (fn declaration (fn heap (fn name (((((symbol.= name) (fn-declaration.name declaration)) (fn _ (some (fn heap' (fn stack (((interpret-operation' (fn-declaration.value declaration)) stack) heap')))))) (fn _ (heap name))) nil)))))
(def operation.fold (fix (fn operation.fold (fn operation (fn acc (fn f ((f ((with (type-name operation)) (fn type (((((symbol.= type) (symbol local-variable-operation)) (fn _ acc)) (fn _ (((((symbol.= type) (symbol global-variable-operation)) (fn _ acc)) (fn _ (((((symbol.= type) (symbol def-operation)) (fn _ (((operation.fold (def-operation.value operation)) acc) f))) (fn _ (((((symbol.= type) (symbol fn-operation)) (fn _ (((operation.fold (fn-operation.value operation)) acc) f))) (fn _ (((((symbol.= type) (symbol symbol-operation)) (fn _ acc)) (fn _ (((((symbol.= type) (symbol apply-operation)) (fn _ (((operation.fold (apply-operation.arg operation)) (((operation.fold (apply-operation.fn operation)) acc) f)) f))) (fn _ (((((symbol.= type) (symbol line-number-operation)) (fn _ (((operation.fold (line-number-operation.operation operation)) acc) f))) (fn _ (((((symbol.= type) (symbol nil-operation)) (fn _ acc)) (fn _ (error (symbol ...)))) nil))) nil))) nil))) nil))) nil))) nil))) nil))) nil)))) operation)))))))
(def interpret-declaration (fn declaration (fn heap ((((with (type-name declaration)) (fn type (((((symbol.= type) (symbol def-declaration)) (fn _ interpret-def-declaration)) (fn _ (((((symbol.= type) (symbol fn-declaration)) (fn _ interpret-fn-declaration)) (fn _ (error (symbol ...)))) nil))) nil))) declaration) heap))))
(def interpret-declarations (fn declarations (fn heap (((fold declarations) heap) (fn heap' (fn declaration ((interpret-declaration declaration) heap')))))))
(def parse-unused (fix (fn parse-unused (fn path (fn input (fn position (fn continue ((((nil? input) (fn _ (((continue path) input) position))) (fn _ ((with (car input)) (fn head (((((char.= head) linefeed) (fn _ ((((parse-unused path) (cdr input)) (next-line position)) continue))) (fn _ ((((whitespace? head) (fn _ ((((parse-unused path) (cdr input)) (next-char position)) continue))) (fn _ (((((char.= head) semicolon) (fn _ ((((parse-comment path) (cdr input)) (next-char position)) (fn path (fn input (fn position ((((parse-unused path) input) position) continue))))))) (fn _ (((continue path) input) position))) nil))) nil))) nil))))) nil))))))))
(def parse-list (fix (fn parse-list (fn parse-expr (fn path (fn input (fn position (fn continue ((((nil? input) (fn _ (error (symbol "Unexpected end of file")))) (fn _ (((((char.= (car input)) close-parentheses) (fn _ ((((continue nil) path) (cdr input)) (next-char position)))) (fn _ ((((parse-unused path) input) position) (fn path (fn input (fn position ((((parse-expr path) input) position) (fn expr (fn path (fn input (fn position (((((parse-list parse-expr) path) input) position) (fn exprs (fn path (fn input (fn position ((((continue ((cons expr) exprs)) path) input) position))))))))))))))))) nil))) nil)))))))))
(def parse-expr (fix (fn parse-expr (fn path (fn input (fn position (fn continue ((with (car input)) (fn head (((((char.= head) open-parentheses) (fn _ (((((parse-list parse-expr) path) (cdr input)) (next-char position)) (fn exprs (fn path (fn input (fn position' ((((continue ((((list-expr exprs) path) position) position')) path) input) position')))))))) (fn _ (((((char.= head) quote) (fn _ ((((parse-symbol-literal path) (cdr input)) (next-char position)) (fn chars (fn path (fn input (fn position' ((((continue ((((symbol-expr chars) path) position) position')) path) input) position')))))))) (fn _ ((((parse-symbol path) input) position) (fn chars (fn path (fn input (fn position' ((((continue ((((symbol-expr chars) path) position) position')) path) input) position')))))))) nil))) nil))))))))))
(def parse (fix (fn parse (fn path (fn input (fn position ((((parse-unused path) input) position) (fn path (fn input (fn position ((((nil? input) (fn _ nil)) (fn _ ((((parse-expr path) input) position) (fn expr (fn path (fn input (fn position ((cons expr) (((parse path) input) position))))))))) nil)))))))))))
(def tree-map-node ((new-data (symbol tree-map-node)) ((cons (symbol left)) ((cons (symbol right)) ((cons (symbol key)) ((cons (symbol value)) nil))))))
(def tree-map-node.left ((field (symbol tree-map-node)) (symbol left)))
(def tree-map-node.right ((field (symbol tree-map-node)) (symbol right)))
(def tree-map-node.key ((field (symbol tree-map-node)) (symbol key)))
(def tree-map-node.value ((field (symbol tree-map-node)) (symbol value)))
(def tree-map-node-nil (object (symbol tree-map-node-nil)))
(def tree-map-node-nil? (is? (symbol tree-map-node-nil)))
(def tree-map ((new-data (symbol tree-map)) ((cons (symbol node)) ((cons (symbol compare)) nil))))
(def tree-map.node ((field (symbol tree-map)) (symbol node)))
(def tree-map.compare ((field (symbol tree-map)) (symbol compare)))
(def empty-tree-map (fn compare ((tree-map tree-map-node-nil) compare)))
(def default-local-env ((local-env (empty-tree-map compare-symbol)) nil))
(def default-global-env ((((global-env (empty-tree-map compare-symbol)) empty-heap) (empty-tree-map compare-symbol)) nat.0))
(def tree-map-node.get (fix (fn tree-map-node.get (fn node (fn compare (fn key ((((tree-map-node-nil? node) (fn _ null)) (fn _ ((((fold-compare ((compare key) (tree-map-node.key node))) (fn < (((tree-map-node.get (tree-map-node.left node)) compare) key))) (fn > (((tree-map-node.get (tree-map-node.right node)) compare) key))) (fn = (some (tree-map-node.value node)))))) nil)))))))
(def tree-map.get (fn map (fn key (((tree-map-node.get (tree-map.node map)) (tree-map.compare map)) key))))
(def env.get (fn local-env (fn global-env (fn name ((with ((tree-map.get (local-env.locals local-env)) name)) (fn option ((((some? option) (fn _ option)) (fn _ ((tree-map.get (global-env.globals global-env)) name))) nil)))))))
(def generate-symbol-expr (fix (fn generate-symbol-expr (fn name (fn local-env (fn global-env ((with (((env.get local-env) global-env) name)) (fn option ((((some? option) (fn _ (((generated (generate-symbol-expr' (unnull option))) nil) global-env))) (fn _ (((generating ((cons name) nil)) global-env) (fn global-env (((generate-symbol-expr name) local-env) global-env))))) nil)))))))))
(def global-env->env (fn global-env (fn name ((pair ((pair ((global-env.heap global-env) name)) null)) ((((tree-map.get (global-env.globals global-env)) name) (const null)) global-variable.macro?)))))
(def generate-macro-apply-expr (fix (fn generate-macro-apply-expr (fn generate-expr (fn name (fn fn (fn args (fn local-env (fn global-env ((with ((heap.get (global-env.heap global-env)) name)) (fn function ((with (global-env->env global-env)) (fn env ((with ((function env) args)) (fn result ((((result/match result) (fn new-expr (((generate-expr ((expr.with-path (expr.path fn)) new-expr)) local-env) global-env))) (fn errors ((degenerate errors) global-env))) (fn dependencies (((generating dependencies) global-env) (fn global-env (((((generate-macro-apply-expr generate-expr) fn) args) local-env) global-env))))))))))))))))))))
(def generate-macro?-expr (fix (fn generate-macro?-expr (fn generate-expr (fn name (fn fn (fn args (fn local-env (fn global-env ((with (((env.get local-env) global-env) name)) (fn option ((((null? option) (fn _ (((generating ((cons name) nil)) global-env) (fn global-env (((((generate-macro?-expr generate-expr) fn) args) local-env) global-env))))) (fn _ ((with (unnull option)) (fn variable (((((and (global-variable? variable)) (fn _ (global-variable.macro? variable))) (fn _ ((((((generate-macro-apply-expr generate-expr) name) fn) args) local-env) global-env))) (fn _ (((((generate-apply-expr generate-expr) fn) args) local-env) global-env))) nil))))) nil))))))))))))
(def tree-map-node.put (fix (fn tree-map-node.put (fn node (fn compare (fn key (fn value ((((tree-map-node-nil? node) (fn _ ((((tree-map-node tree-map-node-nil) tree-map-node-nil) key) value))) (fn _ ((((fold-compare ((compare key) (tree-map-node.key node))) (fn < ((((tree-map-node ((((tree-map-node.put (tree-map-node.left node)) compare) key) value)) (tree-map-node.right node)) (tree-map-node.key node)) (tree-map-node.value node)))) (fn > ((((tree-map-node (tree-map-node.left node)) ((((tree-map-node.put (tree-map-node.right node)) compare) key) value)) (tree-map-node.key node)) (tree-map-node.value node)))) (fn = ((((tree-map-node (tree-map-node.left node)) (tree-map-node.right node)) key) value))))) nil))))))))
(def tree-map.put (fn map (fn key (fn value ((tree-map ((((tree-map-node.put (tree-map.node map)) (tree-map.compare map)) key) value)) (tree-map.compare map))))))
(def file->tree-map' (fn path (fn !tree-map (fn file ((then-run-with (file.directory? file)) (fn directory? (((directory? (fn _ ((then-run-with (file.child-files file)) (fn child-files (((fold child-files) !tree-map) (file->tree-map' ((append path) (file.name file)))))))) (fn _ ((then-run-with !tree-map) (fn tree-map (impure (((tree-map.put tree-map) ((append path) (file.name file))) file)))))) nil)))))))
(def file->tree-map (fn file (((file->tree-map' nil) (impure (empty-tree-map (compare-list compare-symbol)))) file)))
(def generate-fn-expr-closures (fn closures (fn name (fn local-env (second (((fold ((append closures) name)) ((pair nat.0) (local-env.locals local-env))) (fn vars (fn closure ((pair ((nat.+ nat.1) (first vars))) (((tree-map.put (second vars)) closure) ((local-variable closure) (first vars))))))))))))
(def generating->generated (fn generating' (fn operation (fn global-env (fn continue (((generated operation) nil) (((swap global-env.with-dependents) global-env) ((with (global-env.dependents (generating.global-env generating'))) (fn dependents ((with (car (generating.dependencies generating'))) (fn dependency (((tree-map.put dependents) dependency) (fn global-env ((((null? ((tree-map.get dependents) dependency)) (fn _ (continue global-env))) (fn _ ((with ((unnull ((tree-map.get dependents) dependency)) global-env)) (fn result1 ((with (continue (generate-result.global-env result1))) (fn result2 ((((generate-result.combine result1) result2) (generate-result.global-env result2)) false))))))) nil))))))))))))))
(def generate-global-expr (fix (fn generate-global-expr (fn macro? (fn generate-expr (fn name (fn value (fn local-env (fn global-env ((((some? ((tree-map.get (global-env.globals global-env)) name)) (fn _ ((degenerate ((cons ((concat name) (symbol " has already been defined"))) nil)) global-env))) (fn _ ((with (((swap global-env.with-globals) global-env) (((tree-map.put (global-env.globals global-env)) name) (((global-variable name) (expr.path value)) macro?)))) (fn new-global-env ((((generate-result.match (((generate-expr value) ((local-env.with-def name) local-env)) new-global-env)) (fn degenerate' degenerate')) (fn generating' ((((generating->generated generating') (((def-operation name) (expr.path value)) nil-operation)) global-env) (fn global-env ((((((generate-global-expr macro?) generate-expr) name) value) local-env) global-env))))) (fn generated' ((with (((def-declaration name) (expr.path value)) (generated.operation generated'))) (fn declaration ((with ((tree-map.get (global-env.dependents (generated.global-env generated'))) name)) (fn generating? ((with ((((generate-global-expr' name) value) declaration) generated')) (fn result1 ((with ((unnull generating?) (generated.global-env result1))) (fn result2 ((((null? generating?) (fn _ result1)) (fn _ ((((generated.combine result1) result2) (generate-result.global-env result2)) true))) nil))))))))))))))) nil))))))))))
(def generate-def-expr (generate-global-expr false))
(def generate-macro-expr (generate-global-expr true))
(def closures' (fix (fn closures' (fn local-env (fn acc (fn expr (((expr.match expr) (fn name (fn _ (fn _ (fn _ ((((null? ((tree-map.get (local-env.locals local-env)) name)) (fn _ acc)) (fn _ (((tree-map.put acc) name) true))) nil)))))) (fn exprs (fn _ (fn _ (fn _ (((fold exprs) acc) (closures' local-env)))))))))))))
(def closures (fn local-env ((closures' local-env) (empty-tree-map compare-symbol))))
(def tree-map-node.min-node (fix (fn tree-map-node.min-node (fn node ((((tree-map-node-nil? (tree-map-node.left node)) (fn _ node)) (fn _ (tree-map-node.min-node (tree-map-node.left node)))) nil)))))
(def tree-map-node.remove (fix (fn tree-map-node.remove (fn node (fn compare (fn key ((((tree-map-node-nil? node) (fn _ node)) (fn _ ((((fold-compare ((compare key) (tree-map-node.key node))) (fn < ((((tree-map-node (((tree-map-node.remove (tree-map-node.left node)) compare) key)) (tree-map-node.right node)) (tree-map-node.key node)) (tree-map-node.value node)))) (fn > ((((tree-map-node (tree-map-node.left node)) (((tree-map-node.remove (tree-map-node.right node)) compare) key)) (tree-map-node.key node)) (tree-map-node.value node)))) (fn = ((((tree-map-node-nil? (tree-map-node.left node)) (fn _ (tree-map-node.right node))) (fn _ ((((tree-map-node-nil? (tree-map-node.right node)) (fn _ (tree-map-node.left node))) (fn _ ((with (tree-map-node.min-node (tree-map-node.right node))) (fn min ((((tree-map-node (tree-map-node.left node)) (tree-map-node.right (((tree-map-node.remove (tree-map-node.right node)) compare) key))) (tree-map-node.key min)) (tree-map-node.value min)))))) nil))) nil))))) nil)))))))
(def tree-map.remove (fn map (fn key ((tree-map (((tree-map-node.remove (tree-map.node map)) (tree-map.compare map)) key)) (tree-map.compare map)))))
(def tree-map-node.fold (fix (fn tree-map-node.fold (fn node (fn acc (fn f ((((tree-map-node-nil? node) (fn _ acc)) (fn _ (((tree-map-node.fold (tree-map-node.right node)) (((f (((tree-map-node.fold (tree-map-node.left node)) acc) f)) (tree-map-node.key node)) (tree-map-node.value node))) f))) nil)))))))
(def tree-map.fold (fn map (fn acc (fn f (((tree-map-node.fold (tree-map.node map)) acc) f)))))
(def parse-file (fn file ((then-run-with (file->tree-map file)) (fn tree-map ((then-run-with (file.directory? file)) (fn directory? (((tree-map.fold tree-map) (impure nil)) (fn !acc (fn path (fn file ((then-run-with (file.read file)) (fn chars ((then-run-with !acc) (fn acc (impure ((concat acc) (((parse (init (init (cdr ((flat-map (((directory? (fn _ (cdr path))) (fn _ path)) nil)) (cons slash)))))) chars) ((position nat.1) nat.1))))))))))))))))))
(def tree-map.+ (fn a (fn b (((tree-map.fold a) b) (fn map (fn key (fn value (((tree-map.put map) key) value))))))))
(def tree-map->list (fn map (((tree-map.fold map) nil) (fn list (fn key (fn value ((cons ((pair key) value)) list)))))))
(def global-env.unresolved (fn global-env ((filter ((map (tree-map->list (global-env.dependents global-env))) first)) (fn dependent (null? ((tree-map.get (global-env.globals global-env)) dependent))))))
(def write-result (fn backend (fn result (fn out ((((generate-result.match result) (fn degenerate' ((ostream.writeln stderr) ((concat (symbol "Error: ")) (car (degenerate.errors degenerate')))))) (fn generating' (impure (error ((flat-map (generating.dependencies generating')) ((swap append) space)))))) (fn generated' ((with (global-env.unresolved (generated.global-env generated'))) (fn unresolved ((((nil? unresolved) (fn _ (((backend out) (generated.operation generated')) (generated.declarations generated')))) (fn _ ((ostream.writeln stderr) ((concat (symbol "Error: ")) ((concat (car unresolved)) (symbol " is not defined")))))) nil)))))))))
(def generate-fn-expr' (fix (fn generate-fn-expr' (fn generate-expr (fn name (fn value (fn local-env (fn global-env ((with ((mangle-fn-name (local-env.def local-env)) (global-env.index global-env))) (fn mangled-name ((with ((global-env.with-index ((nat.+ nat.1) (global-env.index global-env))) global-env)) (fn new-global-env ((with ((map (tree-map->list ((closures local-env) value))) first)) (fn closures ((((generate-result.match (((generate-expr value) ((local-env.with-locals (((generate-fn-expr-closures closures) name) local-env)) ((local-env.with-def mangled-name) local-env))) new-global-env)) (fn degenerate' degenerate')) (fn generating' (((generating (generating.dependencies generating')) (generating.global-env generating')) (fn global-env ((((generate-fn-expr' name) value) local-env) global-env))))) (fn generated' ((with ((((fn-declaration mangled-name) (expr.path value)) closures) (generated.operation generated'))) (fn declaration (((generated (((((fn-operation (expr.path value)) mangled-name) name) (generated.operation generated')) ((map closures) (fn closure (generate-symbol-expr' (unnull (((env.get local-env) (generated.global-env generated')) closure))))))) ((append (generated.declarations generated')) declaration)) (((swap global-env.with-heap) (generated.global-env generated')) ((interpret-fn-declaration declaration) (global-env.heap (generated.global-env generated')))))))))))))))))))))))
(def generate-fn-expr (fix (fn generate-fn-expr (fn generate-expr (fn names (fn value (fn local-env (fn global-env ((((nil? (cdr names)) (fn _ (((((generate-fn-expr' generate-expr) (car names)) value) local-env) global-env))) (fn _ ((with ((((list-expr ((cons ((((symbol-expr (symbol fn)) (expr.path value)) (expr.start value)) (expr.end value))) ((cons ((((symbol-expr (last names)) (expr.path value)) (expr.start value)) (expr.end value))) ((cons value) nil)))) (expr.path value)) (expr.start value)) (expr.end value))) (fn new-value (((((generate-fn-expr generate-expr) (init names)) new-value) local-env) global-env))))) nil)))))))))
(def generate-list-expr (fn generate-expr (fn exprs (fn local-env (fn global-env ((((nil? exprs) (fn _ ((degenerate ((cons (symbol "List of expressions is empty.")) nil)) global-env))) (fn _ (((expr.match (car exprs)) (fn name (fn path (fn start (fn end ((((((list.= char.=) name) (symbol fn)) (fn _ (((((match-fn-expr (cdr exprs)) ((degenerate ((cons (symbol "Function has no expression.")) nil)) global-env)) ((degenerate ((cons (symbol "Function has no arguments.")) nil)) global-env)) (fn expr ((degenerate ((cons (symbol "Function argument is not a symbol.")) nil)) global-env))) (fn args (fn expr (((((generate-fn-expr generate-expr) args) expr) local-env) global-env)))))) (fn _ ((((((list.= char.=) name) (symbol def)) (fn _ ((((((match-def-expr (cdr exprs)) ((degenerate ((cons (symbol "Definition has no name.")) nil)) global-env)) ((degenerate ((cons (symbol "Definition has no expression.")) nil)) global-env)) ((degenerate ((cons (symbol "Definition has extra expressions.")) nil)) global-env)) (fn name ((degenerate ((cons (symbol "Definition name is not a symbol.")) nil)) global-env))) (fn name (fn expr (((((generate-def-expr generate-expr) name) expr) local-env) global-env)))))) (fn _ ((((((list.= char.=) name) (symbol macro)) (fn _ ((((((match-macro-expr (cdr exprs)) ((degenerate ((cons (symbol "Macro has no name.")) nil)) global-env)) ((degenerate ((cons (symbol "Macro has no expression.")) nil)) global-env)) ((degenerate ((cons (symbol "Macro has extra expressions.")) nil)) global-env)) (fn name ((degenerate ((cons (symbol "Macro name is not a symbol.")) nil)) global-env))) (fn name (fn expr (((((generate-macro-expr generate-expr) name) expr) local-env) global-env)))))) (fn _ ((((((list.= char.=) name) (symbol symbol)) (fn _ (((((match-symbol-literal-expr (cdr exprs)) ((degenerate ((cons (symbol "Symbol literal has no symbol.")) nil)) global-env)) ((degenerate ((cons (symbol "Symbol literal has extra expressions.")) nil)) global-env)) (fn name ((degenerate ((cons (symbol "Symbol literal is not a symbol.")) nil)) global-env))) (fn name (((generate-symbol-literal-expr name) local-env) global-env))))) (fn _ ((((((generate-macro?-expr generate-expr) name) (car exprs)) (cdr exprs)) local-env) global-env))) nil))) nil))) nil))) nil)))))) (fn _ (fn _ (fn _ (fn _ (((match-apply-expr exprs) ((degenerate ((cons (symbol "Application has no arguments.")) nil)) global-env)) (((((generate-apply-expr generate-expr) (car exprs)) (cdr exprs)) local-env) global-env))))))))) nil))))))
(def generate-expr (fix (fn generate-expr (fn expr (fn local-env (fn global-env ((((generate-result.match (((expr.match expr) (fn name (fn _ (fn _ (fn _ (((generate-symbol-expr name) local-env) global-env)))))) (fn exprs (fn _ (fn _ (fn _ ((((generate-list-expr generate-expr) exprs) local-env) global-env))))))) (fn degenerate' degenerate')) (fn generating' generating')) (fn generated' (((generated ((line-number-operation (generated.operation generated')) (position.line (expr.start expr)))) (generated.declarations generated')) (generated.global-env generated'))))))))))
(def generate-exprs' (fix (fn generate-exprs' (fn exprs (fn result ((((nil? exprs) (fn _ result)) (fn _ ((with ((((generate-result.match (((generate-expr (car exprs)) default-local-env) (generate-result.global-env result))) (fn degenerate' degenerate')) (fn generating' ((((generating->generated generating') nil-operation) (generate-result.global-env result)) (fn global-env (((generate-expr (car exprs)) default-local-env) global-env))))) (fn generated' generated'))) (fn car-result ((generate-exprs' (cdr exprs)) ((((generate-result.combine result) car-result) (generate-result.global-env car-result)) true)))))) nil))))))
(def generate-exprs (fn exprs (fn global-env ((generate-exprs' exprs) (((generated nil-operation) nil) global-env)))))
(def generate (fn exprs (impure ((generate-exprs exprs) default-global-env))))
(def run-compile (fn args ((with (get-backend (car args))) (fn backend ((with ((file.child file.local-file) (cadr args))) (fn in ((with ((file.child file.local-file) (caddr args))) (fn out ((then-run-with (parse-file in)) (fn exprs ((then-run-with (generate exprs)) (fn result (((write-result backend) result) out)))))))))))))
(def "" (fn args ((with (car args)) (fn mode (((((symbol.= mode) (symbol compile)) (fn _ (run-compile (cdr args)))) (fn _ (error ((concat (symbol "Could not find mode ")) mode)))) nil)))))
